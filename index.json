[{"categories":["Python","Python常用库"],"content":"前言 相信你和我一样，在日常的工作中，requests 库被广泛使用。今天我要为你介绍一款号称下一代全功能的 HTTP 客户端：httpx。 什么是 httpx httpx 是 Python3 的全功能客户端，支持同步\u0026异步 API，同时支持 HTTP/1.1 和 HTTP/2。 相比其他 HTTP 库，httpx 具有更加易用的接口，更加强大的功能，是未来 Python 开发者的不二选择。 安装和使用 ","date":"2021-07-23","objectID":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/:0:0","tags":["Python","requests"],"title":"httpx | 优秀的HTTP客户端","uri":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"categories":["Python","Python常用库"],"content":"安装 pip install httpx ","date":"2021-07-23","objectID":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/:1:0","tags":["Python","requests"],"title":"httpx | 优秀的HTTP客户端","uri":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"categories":["Python","Python常用库"],"content":"get import httpx # get obj res = httpx.get('https://www.baidu.com') print(res,res.status_code) # response content,text print(res.content,res.text) 代码运行结果代码运行结果 \" 代码运行结果 对于 content 和 text 的去区别，从图中可以直观的看到，content 的类型为 bytes，而 text 的类型为 str。 ","date":"2021-07-23","objectID":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/:2:0","tags":["Python","requests"],"title":"httpx | 优秀的HTTP客户端","uri":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"categories":["Python","Python常用库"],"content":"post # post obj res = httpx.post('http://127.0.0.1:4523/mock/351132/pet',data={'name':'Python测试和开发','status':'Python_Lab'}) print(res.text,type(res.content),res.status_code,res.encoding) 代码运行结果代码运行结果 \" 代码运行结果 因为我们使用了 mock server，所以接口返回的数据可能和我们请求的不一致。 ","date":"2021-07-23","objectID":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/:3:0","tags":["Python","requests"],"title":"httpx | 优秀的HTTP客户端","uri":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"categories":["Python","Python常用库"],"content":"put # put pbj res = httpx.put('http://127.0.0.1:4523/mock/351132/pet',params={'apifoxResponseId':'321249'}) print(res.status_code,res.encoding,res.text) 代码运行结果代码运行结果 \" 代码运行结果 ","date":"2021-07-23","objectID":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/:4:0","tags":["Python","requests"],"title":"httpx | 优秀的HTTP客户端","uri":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"categories":["Python","Python常用库"],"content":"delete # delete obj res = httpx.delete('http://127.0.0.1:4523/mock/351132/pet/1') print(res.status_code,res.encoding,res.text) 代码运行结果代码运行结果 \" 代码运行结果 高级用法 ","date":"2021-07-23","objectID":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/:5:0","tags":["Python","requests"],"title":"httpx | 优秀的HTTP客户端","uri":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"categories":["Python","Python常用库"],"content":"处理 json 通常对于 content 返回是 bytes 或者 str 的数据，我们需要单独使用 json 模块进行数据转换，但是现在我们可以直接使用 httpx 为我们提供的 json 方法拿到字典对象，从而方便的进行数据处理。 import httpx # json res = httpx.get('https://getman.cn/mock/post') print(type(res.text),type(res.content),type(res.json()),res.json()) 代码运行结果代码运行结果 \" 代码运行结果 ","date":"2021-07-23","objectID":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/:6:0","tags":["Python","requests"],"title":"httpx | 优秀的HTTP客户端","uri":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"categories":["Python","Python常用库"],"content":"处理二进制 当我们需要下载图片的时候，通常我们是将 content 的内容分块读取，然后写入文件。但是 httpx 建议我们使用 pillow 和 io 来处理图片的二进制内容。 import httpx from PIL import Image from io import BytesIO # bytes res = httpx.get('http://localhost:8765/um/imgs/') print(res.status_code) ff = Image.open(BytesIO(res.content)) ff.save('xx.png') 代码运行结果下载的图片 \" 代码运行结果 httpx 支持所有 requests 的 raise_for_status()等所有方法，还新增了部分特性，例如 httpx.codes.OK 代替 200 响应码的短语等动能。总之，httpx 是一款值得学习的优秀软件。 ","date":"2021-07-23","objectID":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/:7:0","tags":["Python","requests"],"title":"httpx | 优秀的HTTP客户端","uri":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"categories":["Python","Python常用库"],"content":"官方文档 https://www.python-httpx.org/ 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-07-23","objectID":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/:8:0","tags":["Python","requests"],"title":"httpx | 优秀的HTTP客户端","uri":"/httpx-%E4%BC%98%E7%A7%80%E7%9A%84http%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"categories":["Python","Python进阶"],"content":"通常，当我们需要对对象的敏感属性或者不希望外部直接访问的属性进行私有化，但是某些时候我们又需要对这些私有属性进行修改，该怎么处理呢？ 1、几个概念 _a(前置单下划线)，这种属性仅表示约定的私有，非真正的私有。 __a(前置双下划线)，这种属性表示私有，无法在外部访问。 _a_(前后双下划线)，这种属性标识系统属性。(可选) a_(后置单下划线)，这种属性是为了避免和保留关键字冲突。(可选) 2、举个例子 ","date":"2021-07-15","objectID":"/python%E7%9A%84property%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:0:0","tags":["Python","装饰器"],"title":"Python的@property是干嘛的？","uri":"/python%E7%9A%84property%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶"],"content":"定义一个类： class Student(object): _sex='male' __age=0 执行：（私有属性无法在外部访问） \u003e\u003e\u003e stu = Student() \u003e\u003e\u003e stu._sex 'male' \u003e\u003e\u003e stu.__age Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e AttributeError: 'Student' object has no attribute '__age' \u003e\u003e\u003e 3、解决问题 从上面的类中我们可以看到，私有属性无法在类实例中访问，怎么办呢？当我们需要对类的私有属性__age进行查询和修改的时候，我们可以定义get_age和set_age去实现。 class Student(object): _sex='male' __age=0 def get_age(self): return self.__age def set_age(self,age): self.__age = age 执行： \u003e\u003e\u003e stu = Student() \u003e\u003e\u003e stu.get_age() 0 \u003e\u003e\u003e stu.set_age(18) \u003e\u003e\u003e stu.get_age() 18 \u003e\u003e\u003e 4、换个方法 但是上面的这种方式略显复杂，如果在私有属性较多的类中就不太适用了，所以我们期望寻求一种更简单的方式去解决这个问题，比如将这个私有属性转化为另一个属性。告诉你个好消息，Python已经帮我们实现了，这就是@property。 class Student(object): _sex='male' __age=0 def get_age(self): return self.__age def set_age(self,age): self.__age = age @property def age(self): return self.__age 执行： \u003e\u003e\u003e from payhlib import Student \u003e\u003e\u003e s = Student() \u003e\u003e\u003e s.age 0 \u003e\u003e\u003e s.set_age(19) \u003e\u003e\u003e s.age 19 \u003e\u003e 在上面我们将__age私有属性转换为了age属性，你可能会想，既然私有属性转换为了属性，那我们是不是可以直接修改它呢？答案是不行，因为property虽然将__age转换为了属性，但是其不具备setter功能，需要我们去添加。 \u003e\u003e\u003e from payhlib import Student \u003e\u003e\u003e s = Student() \u003e\u003e\u003e s.age 0 \u003e\u003e\u003e s.age=20 Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e AttributeError: can't set attribute \u003e\u003e\u003e 添加setter方法 class Student(object): _sex='male' __age=0 def get_age(self): return self.__age def set_age(self,age): self.__age = age @property def age(self): return self.__age @age.setter def age(self,value): self.__age=value 执行： \u003e\u003e\u003e from payhlib import Student \u003e\u003e\u003e s = Student() \u003e\u003e\u003e s.age 0 \u003e\u003e\u003e s.age=20 \u003e\u003e\u003e s.age 20 \u003e\u003e\u003e 到此，@peoperty分享完毕，关于它的实现原理你可以查看源码进行研究。 源码\" 源码 ","date":"2021-07-15","objectID":"/python%E7%9A%84property%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:1:0","tags":["Python","装饰器"],"title":"Python的@property是干嘛的？","uri":"/python%E7%9A%84property%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶"],"content":"什么是闭包 Python中的闭包是一个比较模糊的概念，有很多朋友都认为不好理解，但是随着深入学习，就会发现闭包无论如何都是需要去理解的，下面我将自己对闭包的理解进行阐述，希望能够对你有所帮助 ~ 我们可以将闭包理解为一种特殊的函数，这种函数由两个函数的嵌套组成，且称之为外函数和内函数，外函数返回值是内函数的引用，此时就构成了闭包。 闭包的格式 如下： def 外层函数(参数): def 内层函数(): print(\"内层函数执行\", 参数) return 内层函数 内层函数的引用 = 外层函数(\"传入参数\") 内层函数的引用() 外层函数中的参数，不一定要有，据情况而定，但是一般情况下都会有并在内函数中使用到 闭包的实例 如下： def outfunc(a): # 定义外函数 def infunc(b): # 定义内函数 return a*b # 内函数的返回值 return infunc # 外函数的返回值，返回内函数的对象 func_instance = outfunc(8) # 外函数的实例，是一个function对象 print(type(func_instance)) # 打印外函数实例的类型 res = func_instance(10) # 外函数实例的调用 print(res) 输出 ➜ test git:(master) ✗ python3 testpy.py \u003cclass 'function'\u003e 80 在上面的代码中，内函数直接使用了外函数的变量值，那如果想要在内函数中对外函数的变量值进行修改，怎么操作呢？ 修改外函数的变量值 想要修改外函数的变量值，需要用到nonlocal关键字。 def outfunc(a): def infunc(b): nonlocal a a = a*2 return a*b return infunc func_instance = outfunc(8) print(type(func_instance)) res = func_instance(10) print(res) 输出 ➜ test git:(master) ✗ python3 testpy.py \u003cclass 'function'\u003e 160 如上即可。 闭包的使用场景 Python中，闭包的主要用途就是用于装饰器的实现。后续讲解。 还有就是可以简化参数重复传递，比如： def add(a,b,c): print(a*b*c) add(1,2,1) add(1,2,2) add(1,2,3) add(1,2,4) add(1,2,5) 输出 ➜ test git:(master) ✗ python3 testpy.py 2 4 6 8 10 你会发现，a和b是固定不变的，我们怎么样才能减少a和b的传参，而只改变c的值呢？这个时候闭包就起到了作用。 def addNew(a,b): def addC(c): return a*b*c return addC func_ins = addNew(1,2) print(func_ins(1)) print(func_ins(2)) print(func_ins(3)) print(func_ins(4)) print(func_ins(5)) 输出 ➜ test git:(master) ✗ python3 testpy.py 2 4 6 8 10 ","date":"2021-07-15","objectID":"/%E9%97%AD%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:0:0","tags":["Python","闭包"],"title":"Python的闭包是什么？","uri":"/%E9%97%AD%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶"],"content":"基本的魔法方法 名称 解释 _new_(cls[, …]) 在一个对象实例化的时候所调用的第一个方法 _init_(self[, …]) 构造器，当一个实例被创建的时候调用的初始化方法 _del_(self) 析构器，当一个实例被销毁的时候调用的方法 _call_(self[, args…]) 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.call(a, b) _len_(self) 定义当被 len() 调用时的行为 _repr_(self) 定义当被 repr() 调用时的行为 _str_(self) 定义当被 str() 调用时的行为 _bytes_(self) 定义当被 bytes() 调用时的行为 _hash_(self) 定义当被 hash() 调用时的行为 _bool_(self) 定义当被 bool() 调用时的行为，应该返回 True 或 False _format_(self, format_spec) 定义当被 format() 调用时的行为 有关属性 名称 解释 _getattr_(self, name) 定义当用户试图获取一个不存在的属性时的行为 _getattribute_(self, name) 定义当该类的属性被访问时的行为 _setattr_(self, name, value) 定义当一个属性被设置时的行为 _delattr_(self, name) 定义当一个属性被删除时的行为 _dir_(self) 定义当 dir() 被调用时的行为 _get_(self, instance, owner) 定义当描述符的值被取得时的行为 _set_(self, instance, value) 定义当描述符的值被改变时的行为 _delete_(self, instance) 定义当描述符的值被删除时的行为 比较操作符 名称 解释 _lt_(self, other) 定义小于号的行为：x \u003c y 调用 x.lt(y) _le_(self, other) 定义小于等于号的行为：x \u003c= y 调用 x.le(y) _eq_(self, other) 定义等于号的行为：x == y 调用 x.eq(y) _ne_(self, other) 定义不等号的行为：x != y 调用 x.ne(y) _gt_(self, other) 定义大于号的行为：x \u003e y 调用 x.gt(y) _ge_(self, other) 定义大于等于号的行为：x \u003e= y 调用 x.ge(y) 算数运算符 名称 解释 _add_(self, other) 定义加法的行为：+ _sub_(self, other) 定义减法的行为：- _mul_(self, other) 定义乘法的行为：* _truediv_(self, other) 定义真除法的行为：/ _floordiv_(self, other) 定义整数除法的行为：// _mod_(self, other) 定义取模算法的行为：% _divmod_(self, other) 定义当被 divmod() 调用时的行为 _pow_(self, other[, modulo]) 定义当被 power() 调用或 ** 运算时的行为 _lshift_(self, other) 定义按位左移位的行为：« _rshift_(self, other) 定义按位右移位的行为：» _and_(self, other) 定义按位与操作的行为：\u0026 _xor_(self, other) 定义按位异或操作的行为：^ _or_(self, other) 定义按位或操作的行为： 反运算 名称 解释 _radd_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rsub_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rmul_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rtruediv_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rfloordiv_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rmod_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rdivmod_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rpow_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rlshift_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rrshift_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rand_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rxor_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _ror_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） 增量赋值运算 名称 解释 _iadd_(self, other) 定义赋值加法的行为：+= _isub_(self, other) 定义赋值减法的行为：-= _imul_(self, other) 定义赋值乘法的行为：*= _itruediv_(self, other) 定义赋值真除法的行为：/= _ifloordiv_(self, other) 定义赋值整数除法的行为：//= _imod_(self, other) 定义赋值取模算法的行为：%= _ipow_(self, other[, modulo]) 定义赋值幂运算的行为：**= _ilshift_(self, other) 定义赋值按位左移位的行为：«= _irshift_(self, other) 定义赋值按位右移位的行为：»= _iand_(self, other) 定义赋值按位与操作的行为：\u0026= _ixor_(self, other) 定义赋值按位异或操作的行为：^= _ior_(self, other) 定义赋值按位或操作的行为： 一元操作符 名称 解释 _pos_(self) 定义正号的行为：+x _neg_(self) 定义负号的行为：-x _abs_(self) 定义当被 abs() 调用时的行为 _invert_(self) 定义按位求反的行为：~x 类型转换 名称 解释 _complex_(self) 定义当被 complex() 调用时的行为（需要返回恰当的值） _int_(self) 定义当被 int() 调用时的行为（需要返回恰当的值） _float_(self) 定义当被 float() 调用时的行为（需要返回恰当的值） _round_(self[, n]) 定义当被 round() 调用时的行为（需要返回恰当的值） _index_(self) 1. 当对象是被应用在切片表达式中时，实现整形强制转换 2. 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 index 3. 如果 index 被定义，则 int 也需要被定义，且返回相同的值 上下文管理（with 语句） 名称 解释 _enter_(self) 1. 定义当使用 with 语句时的初始化行为 2. enter 的返回值被 with 语句的目标或者 as 后的名字绑定 _exit_(self, exc_type, exc_value, traceback) 1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么 2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 容器类型 名称 解释 _len_(self) 定义当被 len() 调用时的行为（返回容器中元素的个数） _getitem_(self, key) 定义获取容器中指定元素的行为，相当于 self[key] _setitem_(self, key, value) 定义设置容器中指定元素的行为，相当于 self[key] = value _delitem_(self, key) 定义删除容器中指定元素的行为，相当于 del self[key] _iter_(self) 定义当迭代容器中的元素的行为 _reversed_(self) 定义当被 reversed() 调用时的行为 _contains_(self, item) 定义当使用成员测试运算符（in 或 not in）时的行为 ","date":"2021-07-15","objectID":"/%E5%B9%B2%E8%B4%A7python%E7%9A%84%E9%AD%94%E6%95%B0%E6%96%B9%E6%B3%95%E4%B8%80%E8%A7%88%E8%A1%A8-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:0:0","tags":["Python","魔法方法"],"title":"Python的魔法方法一览表","uri":"/%E5%B9%B2%E8%B4%A7python%E7%9A%84%E9%AD%94%E6%95%B0%E6%96%B9%E6%B3%95%E4%B8%80%E8%A7%88%E8%A1%A8-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶"],"content":"接【简明】彻底搞清楚Python的装饰器，我们继续介绍类装饰器+带参数的装饰+多装饰器，顾名思义类装饰器就是类闭包。 定义一个类装饰器 需求：实现一个类装饰器，能够在方法执行时打印日志，并且发送通知到指定地方。 from functools import wraps class logAndNotify(object): # 初始化，定义日志路径 def __init__(self,logfile='service.log'): self.logfile = logfile # 使类成为可调用对象 def __call__(self,func): @wraps(func) def wrap_func(*args,**kwargs): info = func.__name__+'was called' # 实现写日志 with open(self.logfile,'a') as f: f.write(info+'\\n') # 实现通知 self.notify() return func(*args,**kwargs) return wrap_func def notify(self): print('notify has been send...') @logAndNotify() def sayHi(name): print('hello',name,'!') res = sayHi('phyger') print(res) 执行结果： ➜ RemoteWorking git:(master) ✗ /usr/bin/python3 /root/RemoteWorking/test/test.py notify has been send... hello phyger ! None 类装饰器功能扩展 如果我们想要在此类装饰器的基础上，增加发送邮件的功能，就可以利用类的继承特性来实现。 from functools import wraps class logAndNotify(object): # 初始化，定义日志路径 def __init__(self, logfile=\"service.log\"): self.logfile = logfile # 使类成为可调用对象 def __call__(self, func): @wraps(func) def wrap_func(*args, **kwargs): info = func.__name__ + \"was called\" # 实现写日志 with open(self.logfile, \"a\") as f: f.write(info + \"\\n\") # 实现通知 self.notify() return func(*args, **kwargs) return wrap_func def notify(self): print(\"notify has been send...\") class NewWarp(logAndNotify): # 初始化邮件地址 def __init__(self, email_address='phyger@qq.com', *args, **kwargs): self.email_address = email_address super(NewWarp,self).__init__(*args, **kwargs) # 重写notify方法 def notify(self): print(\"notify has been send...\") print('email sended...to',self.email_address) @NewWarp() def sayHi(name): print(\"hello\", name, \"!\") res = sayHi(\"phyger\") print(res) 执行结果： ➜ RemoteWorking git:(master) ✗ /usr/bin/python3 /root/RemoteWorking/test/test.py notify has been send... email sended...to phyger@qq.com hello phyger ! None 带参数的装饰器 当我们需要根据不同的场景对函数进行不同的装饰操作的时候，我们需要使用到带参数的装饰器。 例：日志级别控制 import logging from functools import wraps def logg(level): def mid(func): @wraps(func) def inner(*args, **kwargs): # log设置 #logging.basicConfig(format=' %(asctime)s - %(levelname)s -%(message)s') logging.basicConfig(format = '\"%(asctime)s- %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s\"') logger = logging.getLogger() logger.setLevel(level) # logger打印 logger.info('{} start...'.format(func.__name__)) logger.error('{} errors...'.format(func.__name__)) logger.warn('{} warnning...'.format(func.__name__)) logger.debug('{}end...'.format(func.__name__)) return func(*args, **kwargs) return inner return mid @logg(level='DEBUG') def sayHi(name): print('hi,',name) @logg(level='INFO') def sayBye(name): print('bye',name) sayHi(name='phyger') sayBye(name='phyger') 执行输出： ➜ RemoteWorking git:(master) ✗ /usr/bin/python3 /root/RemoteWorking/test/test.py \"2020-10-31 11:23:42,161 - test.py[line:15] - INFO: sayHi start...\" \"2020-10-31 11:23:42,161 - test.py[line:16] - ERROR: sayHi errors...\" \"2020-10-31 11:23:42,162 - test.py[line:17] - WARNING: sayHi warnning...\" \"2020-10-31 11:23:42,162 - test.py[line:18] - DEBUG: sayHiend...\" hi, phyger \"2020-10-31 11:23:42,162 - test.py[line:15] - INFO: sayBye start...\" \"2020-10-31 11:23:42,162 - test.py[line:16] - ERROR: sayBye errors...\" \"2020-10-31 11:23:42,162 - test.py[line:17] - WARNING: sayBye warnning...\" bye phyger 可以看到： 当设置最高级别ERROR的时候，所有级别的日志都打印。 当设置INFO级别的的时候，DEBUG最低级别的日志不打印。 多装饰器 当有多个不能够耦合的功能需要在函数上增加时，我们需要使用多个装饰器，怎么用呢？ 例：实现日志和发送通知的分离 import logging from functools import wraps def wrap1(func): def inner1(*args, **kwargs): print('start') func(*args, **kwargs) print('end') return True return inner1 def wrap2(func): def inner2(*args, **kwargs): print(\"msg has sended...\") func(*args, **kwargs) return True return inner2 @wrap1 @wrap2 def sayHi(name): print('hi',name) sayHi(name='phyher') 执行输出： ➜ RemoteWorking git:(master) ✗ /usr/bin/python3 /root/RemoteWorking/test/test.py start msg has sended... hi phyher end ","date":"2021-07-15","objectID":"/%E9%80%8F%E5%BD%BBpython%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%9B%E9%98%B6%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8-%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8-%E5%A4%9A%E8%A3%85%E9%A5%B0%E5%99%A8-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:0:0","tags":["Python","装饰器"],"title":"Python装饰器进阶（类装饰器+带参数的装饰器+多装饰器）","uri":"/%E9%80%8F%E5%BD%BBpython%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%9B%E9%98%B6%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8-%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8-%E5%A4%9A%E8%A3%85%E9%A5%B0%E5%99%A8-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"什么是 token token（也称令牌）就是一串字符，其作用是为了减轻频繁进行用户名和密码的验证而对服务器产生的压力。客户端首次访问通过正确的用户名和密码从服务端拿到 token，之后客户端携带 token 即可完成验证，无需重复携带用户名和密码。 ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:0","tags":["Python","FastApi","Token"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"JWT JWT 全名 json web token，它是一种开放的标准，其带有数字签名，用于 json 对象的安全传输。 怎么生成 token 我们已经知道 token 是一串字符，我们可以通过一些秘钥+用户名+时间戳等字符组合，使用 base64 对其进行加密，从而生成 token 颁发给客户端。然后对客户端携带的 token 进行解密，拿到秘钥，用户名，时间戳，最后对这些参数进行校验就可以判断 token 正确与否和是否过期。 以上为 token 生成的原理，在实际开发中，我们可以直接使用现成的第三方库（如：python-jose）。 ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:1","tags":["Python","FastApi","Token"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"常用的 JWT 库 python-jose pyjwt jwcrypto authlib ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:2","tags":["Python","FastApi","Token"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"安装 JWT 库 pip install python-jose ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:3","tags":["Python","FastApi","Token"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"生成 token # 从jose导入jwt，后面使用jwt生成token from jose import jwt # 导入日期模块，用来验证token过期时间 from datetime import datetime,timedelta # 定义秘钥，很重要，请勿泄露 SECRET_KEY = 'phyger' # 生成token的代码，token过期时长定义为默认参数，单位为秒 def create_token(seconds=60): # 定义token过期时间，为当前utc时间加上token有效期 expire = datetime.utcnow()+timedelta(seconds=seconds) # 此处即为生成token的payload，sub自定义（可选用户名），uid自定义（可选设备id等） # to_endoe可以是一个空的字典，但是不建议这样做 to_encode = {\"exp\":expire,\"sub\":SECRET_KEY,\"uid\":\"123456\"} # 使用jwt生成token，token是根据payload和秘钥共同生成。 jwt_token = jwt.encode(claims=to_encode,key=SECRET_KEY) return jwt_token jose 的 JWT 默认采用 HS256 加密方式。 运行代码 \u003e python utm.py eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MTI1MjY0OTgsInN1YiI6InBoeWdlciIsInVpZCI6IjEyMzQ1NiJ9.TnRFBFX_2Jn3VU26n603l5uOQyB9bOOWSxBQUr6tBA4 可以看到，token 已经生成。 上面，我们已经介绍了 token 的生成，是直接使用的第三方库 jose，当然 jose 可以生成 token，想必他也可以校验 token 了。 token 校验 ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:4","tags":["Python","FastApi","Token"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"代码 from jose import jwt # 导入token校验的两种异常，一种是token超时异常，一种是token错误异常 from jose.exceptions import ExpiredSignatureError, JWTError def judge_token(token): # 尝试解密，解密成功后，秘钥，payload，有效时长校验通过，则会返回payload try: payload = jwt.decode(token,SECRET_KEY) print(payload) return True # 否则，则捕获异常，进行提示 except ExpiredSignatureError as e: print('token过期了！') return False except JWTError as e: print('token验证失败！') return False 按照传统的 jwt 协议，我们需要解密 token 后，对 token 的秘钥，payload，有效时长进行单独的校验。以上，token 的秘钥，payload，有效时长，jose 都帮我们完成了，我们只需要调用 jose.jwt 的 encode 和 deode 就可以完成加解密。 ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:5","tags":["Python","FastApi","Token"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"执行校验 if __name__ == \"__main__\": tk=create_token() print(tk) res1=judge_token(tk) print(res1) import time time.sleep(60) res2=judge_token(tk) print(res2) 执行结果 \u003e python utm.py eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MTI1Mjg0MzYsInN1YiI6InBoeWdlciIsInVpZCI6IjEyMzQ1NiJ9.yVhoAKyZFvQi3q4wqd1JoRondl9A6wUaALueP00oyhc {'exp': 1612528436, 'sub': 'phyger', 'uid': '123456'} True token过期了！ False``` \u003e 因为默认token的有效期为60秒，我们在第二次校验token前睡眠了61秒，所以第二次的校验结果为过期！ **使用错误的token校验** ```python if __name__ == \"__main__\": res=judge_token('phyger666') print(res) 以上就是本篇的全部内容了，感谢您的阅读，我们再会。 ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:6","tags":["Python","FastApi","Token"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"前言 通常，我们的接口都是需要认证后才能可以访问的，前面我们介绍了 token 的生成和校验，那在 FastApi 中怎么设计需要认证的接口呢？ 定义令牌对象 oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/token/\") 以上/token/为获取 token 的 URI，具体内容如下： class Token(BaseModel): access_token: str token_type: str @app.post('/token/',response_model=Token) async def get_token(response:Response,form_data: OAuth2PasswordRequestForm = Depends()): if form_data.username=='phyger' and form_data.password=='phyger666': response.headers['access_token']=create_token() return {\"access_token\":create_token(),\"token_type\":\"bearer\"} /token/可以返回指定格式的令牌信息。 定义需要认证的接口 @app.get('/format/{name}') async def fmt(name,token=Depends(oauth2_scheme)): print(token) print(type(name)) new_name = name.title() return {'result':new_name} ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:0","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"直接访问此接口 \" 如上，直接访问会提示未认证，这样，我们已经达到了目的，但是怎么样才能实现准确无误的认证呢？ ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:1","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"带上 bearer token 试试 \" 你会发现，我们携带的错误的 token 也能成功，这是为什么呢？ 因为在接口中，我们通过 oauth2_scheme 拿到了 token，这个 token 是标准的 bearer 格式，但是我们没有对其进行校验，所以只要格式正确，接口都能正常返回。 ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:2","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"使用错误的 bearer 格式 \" 如上，使用错误的 bearer 格式的 token，就无法访问接口了。 获取和校验 token 思路：通过上面的代码，我们将获取 token，校验 token 封装成一个静态方法，在需要认证的接口中对这个方法进行依赖即可。 ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:3","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"封装的接口 from utm import judge_token def login_required(token=Depends(oauth2_scheme)): credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"认证失败！\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) if judge_token(token=token): return True else: raise credentials_exception ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:4","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"需要认证的接口 @app.get('/format/{name}') async def fmt(name,token=Depends(login_required)): print(token) print(type(name)) new_name = name.title() return {'result':new_name} ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:5","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"直接访问/format/{name}接口 \" 提示：未认证！ ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:6","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"携带过期的 token 访问 \" 提示：认证失败！ ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:7","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"使用错误 bearer 格式 \" 提示：未认证！ ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:8","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"使用正确有效的 token \" 如上，成功！ 上面，我们将 token 错误，token 过期都统一定义为认证失败！后续可以进行细化。还需要考虑 token 续签的实现。 ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:9","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶"],"content":"什么是装饰器 接“闭包”是什么？，我们可以认为装饰器就是一个闭包函数，同时它也返回了一个函数。 你也可以认为装饰器就是将函数作为参数传递到方法中，进行加工，再返回出来。 装饰器的使用场景 1、附加功能（统一日志格式，定时器） 2、数据的清理和添加（注入类似动态token的数据，修改清理内部数据） 3、函数注册等 装饰器的demo 1、实现函数在执行前后所花费的时间 装饰器的使用格式：@decorator # 定义装饰器 import time def execTime(func): def inner(*args,**kwargs): # 接收参数 time1 = time.time() res = func(*args,**kwargs) time2 = time.time() print(func.__name__,'执行花费',time2-time1,'s') return res # 返回func的返回值 return inner # 返回inner方法对象 # 在execAdd方法上使用execTime装饰器 @execTime def execAdd(a,b): time.sleep(1) return a+b # 调用execAdd res = execAdd(1,2) print(res) 运行结果： python3 test.py execAdd 执行花费 1.0000572204589844 s 3 2、实现日志的统一打印 import time,logging def execTime(func): def inner(*args,**kwargs): time1 = time.time() # 添加方法开始的日志 logging.warning('now func {} start...'.format(func.__name__)) res = func(*args,**kwargs) # 添加方法结束的日志 logging.warning('now func {} finished...'.format(func.__name__)) time2 = time.time() print(func.__name__,'执行花费',time2-time1,'s','\\n') return res return inner @execTime def execAdd(a,b): time.sleep(1) return a+b @execTime def sayHi(name): print('hello,{}.'.format(name)) sayHi('phyger') res = execAdd(1,2) print(res) 输出 python3 test.py WARNING:root:now func sayHi start... hello,phyger. WARNING:root:now func sayHi finished... sayHi 执行花费 0.00700068473815918 s WARNING:root:now func execAdd start... WARNING:root:now func execAdd finished... execAdd 执行花费 1.0020573139190674 s 3 你会看到上面的两个方法在执行前后都会被增加开始和结束的告警日志，而且会统计方法的执行时间，通过这种方式我们可以方便快捷的对方法进行封装。 注意 当我们执行以下代码时： @execTime def sayHi(name): print('hello,{}.'.format(name)) 输出 python3 test.py WARNING:root:now func sayHi start... hello,phyger. WARNING:root:now func sayHi finished... sayHi 执行花费 0.018001317977905273 s inner sayHi方法的name竟然是装饰器的内函数的方法，这不是我们的期望结果啊。我们方法的name和注释被装饰器内函数重写了，我们怎么解决这个问题呢？ Python帮我提供了一个函数来解决这个问题，他就是functools.wraps。 我们重写装饰器来看看效果： from functools import wraps import time,logging def execTime(func): @wraps(func) def inner(*args,**kwargs): time1 = time.time() logging.warning('now func {} start...'.format(func.__name__)) res = func(*args,**kwargs) logging.warning('now func {} finished...'.format(func.__name__)) time2 = time.time() print(func.__name__,'执行花费',time2-time1,'s','\\n') return res return inner # 调用 sayHi('phyger') print(sayHi.__name__) 输出 test.py WARNING:root:now func sayHi start... hello,phyger. WARNING:root:now func sayHi finished... sayHi 执行花费 0.003000020980834961 s sayHi 你能看到，使用了装饰器的sayHi方法的__name__值已经是它自身的值了。 如果你想在当前装饰器的基础上再增加功能，那么你可能需要使用类装饰器，因为类的继承特性可以很好的解决你这个需求。关于类装饰器我们后面再介绍。 ","date":"2021-07-15","objectID":"/%E7%AE%80%E6%98%8E%E5%BD%BB%E5%BA%95%E6%90%9E%E6%B8%85%E6%A5%9Apython%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:0:0","tags":["Python","装饰器"],"title":"彻底搞清楚Python的装饰器","uri":"/%E7%AE%80%E6%98%8E%E5%BD%BB%E5%BA%95%E6%90%9E%E6%B8%85%E6%A5%9Apython%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Markdown","野生技术"],"content":"背景 刚才在某群里无意间看到有位掘友提问：这个插入的图片怎么居中显示？其实我也早有这个疑问，只是懒得去处理。但是看到掘友有疑问，那作为热心肠的我必须帮他答疑解惑。 ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:0:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["Markdown","野生技术"],"content":"掘金原始居中方式 你会发现掘金原始的图片并不居中 尝试第1次 我们都知道，无论是Markdown还是富文本编辑器，最终在网页上的呈现方式都是一样的，无非是HTML+CSS+JS，通过以上简单的理论，我们开始第一次尝试，计划直接将Markdown的图片展示方式用HTML的\u003cimg\u003e标签替代。 ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:1:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["Markdown","野生技术"],"content":"代码 \u003cimg style=\"align:center\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58935071dcee4613bf27ec6e9bb10bc6~tplv-k3u1fbpfcp-watermark.image\" /\u003e ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:2:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["Markdown","野生技术"],"content":"效果 你会发现依然不居中，原因竟是直接在img标签中添加的样式竟然没有生效，证据如下。 尝试第2次 经过上面的失败，我们决定换一种方式，即直接使用style标签来定义样式。 ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:3:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["Markdown","野生技术"],"content":"代码 \u003cstyle type=\"text/css\"\u003e img {align:center} \u003c/style\u003e \u003cimg style=\"align:center\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58935071dcee4613bf27ec6e9bb10bc6~tplv-k3u1fbpfcp-watermark.image\" /\u003e ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:4:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["Markdown","野生技术"],"content":"效果 img {align:center} -_-// 简直没脸看啊，样式直接漏了。 尝试第3次 经过上面的失败，我决定了这次再不成功，我就弃笔从戎了！估计我这小身板儿也进不了部队，哈哈哈。这次我们计划用div包裹img标签，因为通常前端都是这么干的。 ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:5:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["Markdown","野生技术"],"content":"代码 \u003cdiv align=center\u003e \u003cimg src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58935071dcee4613bf27ec6e9bb10bc6~tplv-k3u1fbpfcp-watermark.image\" /\u003e \u003c/div\u003e ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:6:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["Markdown","野生技术"],"content":"效果 (#^.^#)，我去，终于成了。虽然这是很简单的基操，但是能够帮到掘友，我还是很开心的。 多说一句 通过这篇文章，我建议各位掘友能够动手去设计属于自己的主题并且贡献给社区，这样对于推动社区体验无疑是一件小但很好的事情。 以上就是本文的全部内容，如果喜欢记得（四连）：点赞，评论，收藏，转发。 ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:7:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["前端技术"],"content":"前言 相信很多同学在学习 Vue 的时候，会经常用到或者被问题到单向数据流和双向数据绑定的概念，那它两到底有什么区别呢？我们一起来看看。 单向数据流 单向数据流在 Vue 中实际表现就是：当 Model 中的 data 发生变化的时候会单向修改 View 中的值，而 View 中的值发生变化的时候，Model 不会感知。实际应用就是 v-bind 单向数据。 双向数据绑定 和单向数据流相比，双向数据绑定就是多了 View 变化会通知到 Model 层。即 MVVM 的具体实现。无论 Model 还是 View 中的值发生变化，都会通过 ViewModel 通知到对方，实现同步。实际应用就是 v-model 双向数据绑定。 代码 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003e单向\u0026双向\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003e单向数据流\u003c/h1\u003e 现在的时间是：{{ mytime }} \u003cbr\u003e \u003cbutton type=\"button\" @click=\"shuax\"\u003e刷新时间\u003c/button\u003e \u003cbr\u003e\u003cbr\u003e \u003chr \u003e \u003ch1\u003e双向数据绑定\u003c/h1\u003e \u003cinput v-model=\"sxbind\"/\u003e \u003cbr\u003e 你输入的数据是：{{ sxbind }} \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e app = new Vue({ el: '#app', data: { mytime:new Date().toLocaleTimeString(), sxbind:'' }, methods: { shuax:function(){ this.mytime = new Date().toLocaleTimeString(); } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 单向数据流效果 初始页面↑ 初始页面 \" 初始页面 点击刷新时间↑ 点击刷新时间（Model变化View也变） \" 点击刷新时间 Model变化View也变↑ Model变化View也变 \" Model变化View也变 View变化Model不变↑ View变化Model不变 \" View变化Model不变 双向数据绑定效果 Model变化View也变↑ Model变化View也变 \" Model变化View也变 Model变化View也变↑ View变化Model也变 \" Model变化View也变 总结 单向数据流是通过 props 将 Model 层的变化通知到 View 层进行修改。双向数据绑定是通过 Object.defineProperty()的 set() 和 get() 方法来实现的，当某一方发生变化的时候，另一方就会收到更新值的提醒，从而实现数据同步变化。 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-07-14","objectID":"/vue%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/:0:0","tags":["Vue","前端"],"title":"Vue的单向数据流和双向数据绑定","uri":"/vue%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"什么是 Example 你可能注意到了，之前的 docs 中在 response 中的 Example Value 中是没有实例的，这个怎么做呢？ 答案是使用 Filed 对象，也可以在模型中使用 schema_extra。 Requests Example Value ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:0:0","tags":["Python","FastApi"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"Filed from pydantic import BaseModel,Field class ss(BaseModel): name:str = Field(...,example='phyger') age:int = Field(...,example=18) @app.post('/ff/') async def get_ff(ff:ss): res = {'res':ff} return res ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:1:0","tags":["Python","FastApi"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"docs docsdocs \" docs 可以看到，已经有了实例数据 ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:2:0","tags":["Python","FastApi"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"schema_extra from pydantic import BaseModel,Field class ss(BaseModel): name:str age:int class Config: schema_extra = { \"example\":{ \"name\":\"phyger678\", \"age\":20 } } @app.post('/ff/') async def get_ff(ff:ss): res = {'res':ff} return res ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:3:0","tags":["Python","FastApi"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"docs docsdocs \" docs 可以看到，效果已经展现出来了。 Response Example Value 搞定了 Requests 的示例信息，现在我们一起来研究下 Reponse 的示例信息。 ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:4:0","tags":["Python","FastApi"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"代码 from pydantic import BaseModel class info(BaseModel): name:str age:int @router.post('/test') def test(info:info): msg = {\"people_info\":info} return msg ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:5:0","tags":["Python","FastApi"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"效果 你会发现如上的代码在 docs 中是没有 Reponse 的示例信息的。 效果效果 \" 效果 ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:6:0","tags":["Python","FastApi"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"代码-New from pydantic import BaseModel class info(BaseModel): name:str age:int class repMd(BaseModel): people_info:info @router.post('/test',response_model=repMd) def test(info:info): msg = {\"people_info\":info} return msg ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:7:0","tags":["Python","FastApi"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"效果-New 你会发现，Reponse 的示例数据已经搞定。 效果效果 \" 效果 这样做有什么用呢？ 除了上面我们介绍的可以在 docs 中对接口进行信息的完善和请求体的提示以外。Example 部分还可以对整个项目的重构，以及系统对接，交付测试等起到意想不到的良好效果。 还是建议大家在实际开发过程中，能够添加 Requests 和 Reponse 的示例信息，磨刀不误砍柴工，只有在我们项目的初始阶段就定好规则，大家一起遵守，这样才能做出一个好的产品。 以上都是小编在实际工作中深切体会到的，如果前期没有完善的相关注释和文档，将会为后续的维护和测试等造成很大的困扰。返工的成本远比当时盲目赶工时取得的眼前收益大得多！ 做产品还是得脚踏实地，稳步前进！ 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:8:0","tags":["Python","FastApi"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"常用基础嵌套 使用 FastAPI，你可以定义、校验、记录文档并使用任意深度嵌套的模型（归功于 Pydantic）。 ","date":"2021-07-09","objectID":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/:0:0","tags":["Python","FastApi"],"title":"FastApi-09-模型嵌套","uri":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"基础模型 class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None tags: list = [] ","date":"2021-07-09","objectID":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/:0:1","tags":["Python","FastApi"],"title":"FastApi-09-模型嵌套","uri":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"定义类型的字类型 假设我们需要制定一个字段 tags:list 的元素都为 str 类型，怎么做呢？ 答案是：使用 typing 中的 List 类。（指定其他字类型亦是如此） from typing import List tags: List[str] 如上，就定义了一个元素类型为 str 的列表。 嵌套模型 为了方便组合拆解，我们可以将某些模型对象单独声明，然后在其他模型中引用。 class Image(BaseModel): url: str name: str class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None tags: Set[str] = [] image: Optional[Image] = None 如上，我们定义了一个 Image 模型，在 Item 模型中直接使用了。 在实际请求时，我们按照以下格式发送请求体即可。 { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2, \"tags\": [\"rock\", \"metal\", \"bar\"], \"image\": { \"url\": \"http://example.com/baz.jpg\", \"name\": \"The Foo live\" } } 特殊类型 HttpUrl：由 pydantic 提供。 class Image(BaseModel): url: HttpUrl name: str 以上的使用方式，FastApi 支持自动联想补全，数据转换，数据校验，文档自动生成等。 实践 ","date":"2021-07-09","objectID":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/:0:2","tags":["Python","FastApi"],"title":"FastApi-09-模型嵌套","uri":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"基础类型 class Md1(BaseModel): name:str age:int @app.post('/model/1') async def m1(md:Md1): return {'msg':'model is ok!'} 执行测试： 测试结果测试结果 \" 测试结果 根据测试结果，我们可以知道：①FastApi 的模型检验功能很好用。② 当整数被双引号包裹，FastApi 可以根据其限定的类型自动转换。③ 对于数据结构检验有明确的提示。 ","date":"2021-07-09","objectID":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/:1:0","tags":["Python","FastApi"],"title":"FastApi-09-模型嵌套","uri":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"嵌套类型 class Md1(BaseModel): name:str age:int class Md2(BaseModel): city_info:str people_info:Md1 @app.post('/model/1') async def m1(md:Md1): return {'msg':'model is ok!'} @app.put('/model/2') async def m2(md:Md2): return {'msg':'relation model cheking pass!'} 执行测试： 测试结果测试结果 \" 测试结果 根据以上测试结果，我们可以清晰的了解到 FastApi 借助 pydantic 实现的模型嵌套非常优雅。模型嵌套结合动态请求体，我们可以很方便的应对业务变化导致的数据模型变化。 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-09","objectID":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/:2:0","tags":["Python","FastApi"],"title":"FastApi-09-模型嵌套","uri":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"背景 和查询参数一样，路径参数也需要进行限定。 Path 通常，我们会直接使用 name:str='phyger'的方式来限定路径参数的类型和默认值，但是对于路径参数的高级元数据，我们需要借助 FastApi 为我们提供的 Path 对象来实现。 通常路径参数时必须的，所以即便你指定了默认参数，其依然是必须的。 ","date":"2021-07-08","objectID":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:0","tags":["Python","FastApi"],"title":"FastApi-08-路径参数校验","uri":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"路径参数的 title from fastapi import Path @app.get('/path/{name}') async def pth(name:str=Path(...,title='path name')): return {'path_name':name} ","date":"2021-07-08","objectID":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:1:0","tags":["Python","FastApi"],"title":"FastApi-08-路径参数校验","uri":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"限定路径参数的格式 数值校验 大于2：gt=2 小于2：lt=2 大于等于2：ge=2 小于等于2：le=2 from fastapi import Path @app.get('/path/{name}') async def pth(* ,name:int=Path(...,title='path name',ge=2),q:str): return {'path_name':name} PathPath \" Path ","date":"2021-07-08","objectID":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:2:0","tags":["Python","FastApi"],"title":"FastApi-08-路径参数校验","uri":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"路径参数的顺序问题 当我们的业务模型中有两个uri，一个路径参数是固定值，另一个是路径参数是变量，该如何处理呢？ 假设当前业务中的视图有如下两条： @app.get('/path/{name}') async def pth(name:str=Path(...,title='path name')): return {'path_name':name} @app.get('/path/default') async def f1(): return {'msg':'I am default path.'} 分析以上代码，当我们请求/path/default的时候，我们会得到{'msg':'I am default path.'}的结果。 测试一下： 结果结果 \" 结果 这是怎么回事？和我预期的不一致。 这是因为代码中的两个uri冲突了，对于/path/default而言，/path/{name}已经拦截了所有符合/path/xxx的请求。我们只要将他两的顺序调整为固前变后（固定路径参数在前，变化路径参数在后）即可。 ","date":"2021-07-08","objectID":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:3:0","tags":["Python","FastApi"],"title":"FastApi-08-路径参数校验","uri":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"修改的代码 @app.get('/path/default') async def f1(): return {'msg':'I am default path.'} @app.get('/path/{name}') async def pth(name:str=Path(...,title='path name')): return {'path_name':name} 再次测试： 测试结果测试结果 \" 测试结果 可以看到，/path/default已经成功拦截并返回正确的结果。 再测试下非固定参数的功能： 非固定参数非固定参数 \" 非固定参数 可以看到，我们的非固定路径参数的其他功能均正常。 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-08","objectID":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:3:1","tags":["Python","FastApi"],"title":"FastApi-08-路径参数校验","uri":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"问题抛出 前面我们已经了解了查询参数，但是实际开发中我们可能需要限定参数的类型，长度等其他属性。这个时候我们就需要对查询参数进行校验。 类型我们可以通过显示类型进行限制，但是长度等其他属性我们需要借助 FastApi 的 Query 对象来实现。 实例 ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:0","tags":["Python","FastApi"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"实现方式 参数限定，我们需要借助 fastapi 中的 Query 对象来实现。 导入 Query from fastapi import Query ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:1","tags":["Python","FastApi"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"限定参数最大长度 使用参数：max_length @app.get('/len') async def get_len(q:str=Query(...,max_length=2)): res = {'name':'phyger'} if q: res.update({'q':q}) return res max_lengthmax_length \" max_length 从以上测试可知： 查询参数 q 为可选参数、最大长度为 2，超过最大长度 fastapi 将会报错。 ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:2","tags":["Python","FastApi"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"限定参数最小长度 使用参数：min_length @app.get('/len') async def get_len(q:Optional[str]=Query(None,min_length=2,max_length=5)): res = {'name':'phyger'} if q: res.update({'q':q}) return res min_lengthmin_length \" min_length Query 类型的查询参数必须制定默认值。形如：Query(...,min_length=2,max_length=5) 除了限定长度，我们还可以通过 regex 属性来通过正则表达式限定参数格式 ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:3","tags":["Python","FastApi"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"默认查询参数 可选查询参数： 通常我们使用 Optional 类型结合 Query 类型的默认值来实现； async def get_len(q:Optional[str]=Query(None,min_length=2,max_length=5)): pass async def get_len(q:str=Query(None,min_length=2,max_length=5)): pass 以上两种方式都可。 必选查询参数： 通常我们指定 Query 的默认值为...来实现。 async def get_len(q:str=Query(...,min_length=2,max_length=5)): pass 当 Optional 类型和...默认参数同时存在的时候，查询参数依然为必选。 ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:4","tags":["Python","FastApi"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"多个查询参数 当我们需要设计多个查询参数的时候，我们可以这样写。 from typing import List from fastapi import Query @app.get('/len') async def get_len(q:Optional[List[str]]=Query(...,min_length=2,max_length=5)): res = {'name':'phyger'} if q: res.update({'q':q}) return res 多查询参数多查询参数 \" 多查询参数 直接使用 list 也可以 from typing import List from fastapi import Query @app.get('/len') async def get_len(q:Optional[list]=Query(...)): res = {'name':'phyger'} if q: res.update({'q':q}) return res 多查询参数多查询参数 \" 多查询参数 更多的元数据 ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:5","tags":["Python","FastApi"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"title Query 的 title 属性可以让我们指定参数的标题，用做提示。 from fastapi import Query @app.get('/title/') async def title(name:str = Query(...,title=\"test title\",max_length=5,min_length=2)): return {'result':name} ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:6","tags":["Python","FastApi"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"description from fastapi import Query @app.get('/title/') async def title(name:str = Query(...,title=\"test title\",max_length=5,min_length=2,description='test desc')): return {'result':name} ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:7","tags":["Python","FastApi"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"doc 中的效果 doc 中的效果doc 中的效果 \" doc 中的效果 ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:8","tags":["Python","FastApi"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"别名 实际应用中，有时候查询参数可能形如 x-name，这在 python 中不是合法的变量，为了解决类似问题，FastApi 为我们提供了别名 alias 功能。 from fastapi import Query @app.get('/title/') async def title(name:str = Query(...,max_length=5,min_length=2,alias='x-name')): return {'result':name} 别名别名 \" 别名 ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:9","tags":["Python","FastApi"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"参数弃用 当我们计划在后续版本中废弃参数时，我们可以通过 deprecated 属性来提示用户。 from fastapi import Query @app.get('/title/') async def title(name:str = Query(...,max_length=5,min_length=2,alias='x-name',deprecated=True)): return {'result':name} ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:10","tags":["Python","FastApi"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"接口文档中的效果 接口文档中的效果接口文档中的效果 \" 接口文档中的效果 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:11","tags":["Python","FastApi"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"动态请求体 诉求：当我们想要动态的向请求体中增加一个字段，但是不想修改原有的请求体数据模型，怎么办呢？ 答案是：使用动态请求体 Body 实例 ","date":"2021-07-06","objectID":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:0","tags":["Python","FastApi"],"title":"FastApi-06-请求体-3","uri":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"原有数据模型 class Mds(BaseModel): name: str age: int = 18 home: str height: Optional[str] class Mm(BaseModel): title: str phone: str = 'huawei' ","date":"2021-07-06","objectID":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:1","tags":["Python","FastApi"],"title":"FastApi-06-请求体-3","uri":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"原有的视图函数 @app.put('/models/{name}') async def add_model(Mds:Mds,Mm:Mm,name:str,q: Optional[bool] = False): ret = {} if q: ret.update({\"request_name\":name}) if Mds.name: ret.update({\"Name\":Mds.name}) if Mds.height: ret.update({\"height\":Mds.height}) if Mm.title: ret.update({\"Title\":Mm.title}) return ret ","date":"2021-07-06","objectID":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:2","tags":["Python","FastApi"],"title":"FastApi-06-请求体-3","uri":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"向请求体增加一个字段 此时，我们需要修改视图函数即可。 from fastapi import Body @app.put('/models/{name}') async def add_model(Mds:Mds,Mm:Mm,name:str,q: Optional[bool] = False,weight:str=Body(...)): ret = {} if q: ret.update({\"request_name\":name}) if Mds.name: ret.update({\"Name\":Mds.name}) if Mds.height: ret.update({\"height\":Mds.height}) if Mm.title: ret.update({\"Title\":Mm.title}) return ret ","date":"2021-07-06","objectID":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:3","tags":["Python","FastApi"],"title":"FastApi-06-请求体-3","uri":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"接口测试 接口测试接口测试 \" 接口测试 如上图，我们已经成功实现动态增加请求体字段 注意 当请求体为单个模型时，动态字段和请求模型原字段同级。当请求体为多个模型时，动态字段和请求模型类名同级。 ","date":"2021-07-06","objectID":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:4","tags":["Python","FastApi"],"title":"FastApi-06-请求体-3","uri":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"单个数据模型时的请求体 { \"Mds\": { \"name\": \"phyger\", \"home\": \"xian\", \"ok\": \"ok\", \"weight\": \"70kg\" } } ","date":"2021-07-06","objectID":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:5","tags":["Python","FastApi"],"title":"FastApi-06-请求体-3","uri":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"多个数据模型时的请求体 { \"Mds\": { \"name\": \"phyger\", \"home\": \"xian\", \"ok\": \"ok\" }, \"Mm\": { \"title\": \"TSE\", \"phone\": \"xiaomi\" }, \"weight\": \"70kg\" } 对于请求体的介绍我们到这里就基本结束了，我们可以以此作为借鉴，在实际开发中多多实践，以充分感知请求体在开发中的作用。 附：常见的请求体类型 序号 类型 解释 1 multipart/form-data 以表单的形式上传文件 2 application/x-www-from-urlencoded 以键值对的数据格式提交，当action为post时，浏览器将form数据封装到http body中 3 raw 上传任意格式的文本（text，js，json，html，xml） 4 binary 以二进制的形式上传文件 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-06","objectID":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:6","tags":["Python","FastApi"],"title":"FastApi-06-请求体-3","uri":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"请求体+路径参数 实际开发中，我们经常会遇到请求体和路径参数同时存在的场景。 ","date":"2021-07-05","objectID":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:0","tags":["Python","FastApi"],"title":"FastApi-05-请求体-2","uri":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"代码 from pydantic import BaseModel class Mds(BaseModel): name: str age: int = 18 home: str height: Optional[str] @app.post('/models/{name}/') async def add_model(Mds:Mds,name:str): ret = {} ret.update({\"request_name\":name}) if Mds.name: ret.update({\"Name\":Mds.name}) if Mds.height: ret.update({\"height\":Mds.height}) return ret 如上，根据路径参数进行不同的响应。 ","date":"2021-07-05","objectID":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:1","tags":["Python","FastApi"],"title":"FastApi-05-请求体-2","uri":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"接口测试 接口测试接口测试 \" 接口测试 请求体 + 路径参数 + 查询参数 ","date":"2021-07-05","objectID":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:2","tags":["Python","FastApi"],"title":"FastApi-05-请求体-2","uri":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"代码 from pydantic import BaseModel class Mds(BaseModel): name: str age: int = 18 home: str height: Optional[str] @app.put('/models/{name}') async def add_model(Mds:Mds,name:str,q: Optional[bool] = False): ret = {} if q: ret.update({\"request_name\":name}) if Mds.name: ret.update({\"Name\":Mds.name}) if Mds.height: ret.update({\"height\":Mds.height}) return ret ","date":"2021-07-05","objectID":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:3","tags":["Python","FastApi"],"title":"FastApi-05-请求体-2","uri":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"接口测试 接口测试接口测试 \" 接口测试 如上，FastApi 可以智能的，自动的识别各类型参数，并从正确的位置获取数据。 多结构体时的请求体 通常，为了方便结构体定义，我们可能会将不同类型的结构体分别定义在不同的数据模型中。这样，在视图函数的参数中，也将有多个模型参数，那具体怎么使用呢？ ","date":"2021-07-05","objectID":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:4","tags":["Python","FastApi"],"title":"FastApi-05-请求体-2","uri":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"代码 from pydantic import BaseModel from typing import Optional class Mds(BaseModel): name: str age: int = 18 home: str height: Optional[str] class Mm(BaseModel): title: str phone: str = 'huawei' @app.put('/models/{name}') async def add_model(Mds:Mds,Mm:Mm,name:str,q: Optional[bool] = False): ret = {} if q: ret.update({\"request_name\":name}) if Mds.name: ret.update({\"Name\":Mds.name}) if Mds.height: ret.update({\"height\":Mds.height}) if Mm.title: ret.update({\"Title\":Mm.title}) return ret ","date":"2021-07-05","objectID":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:5","tags":["Python","FastApi"],"title":"FastApi-05-请求体-2","uri":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"接口测试 接口测试接口测试 \" 接口测试 如上，当存在 Mds:Mds,Mm:Mm 两个结构体参数的时候，正确的请求体格式为：{\u003c模型类名\u003e:\u003c模型\u003e} { \"Mds\": { \"name\": \"phyger\", \"home\": \"xian\", \"ok\": \"ok\" }, \"Mm\": { \"title\": \"TSE\", \"phone\": \"xiaomi\" } } 对于结构体明确的请求体，我们可以参考本篇内容进行开发实践，那如果在进行代码重构或者业务调整的时候，请求体的数据结构发生了变化，应该如何应对呢？下篇文章我们继续探索！ 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-05","objectID":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:6","tags":["Python","FastApi"],"title":"FastApi-05-请求体-2","uri":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"何为请求体 顾名思义，请求体就是在请求过程中客户端携带的数据。 请求体不是一定要携带的，而且请求体不建议用 GET 请求发送，通常我们会使用 POST 请求发送请求体，当然是用 PUT、DELETE、PATCH 方式也可以发送请求体。 举个栗子 根据请求体做相应的响应，如下返回请求体内容。 FastApi 的请求体需要为 dict 格式 ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:0","tags":["Python","FastApi"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"代码 @app.post('/models/') async def add_model(model:str): return model ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:1","tags":["Python","FastApi"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"接口测试 正常情况 正常情况正常情况 \" 正常情况 异常情况 异常情况异常情况 \" 异常情况 FastApi 会帮助我们进行类型检测，基本格式校验等 请求体校验 通常，我们在开发的时候，需要用户根据特定的结构体来发起请求，从而防止攻击和过滤用户。 ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:2","tags":["Python","FastApi"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"FastApi 的数据模型 在 FastApi 中，我们可以借助 pydantic 的 BaseModel 类来实现请求结构体的定义。 ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:3","tags":["Python","FastApi"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"代码 from pydantic import BaseModel class Mds(BaseModel): name: str age: int home: str @app.post('/models/') async def add_model(model:Mds): return model ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:4","tags":["Python","FastApi"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"接口测试 正常情况 正常情况正常情况 \" 正常情况 异常情况 异常情况异常情况 \" 异常情况 对于错误的，缺失的结构体字段，FastApi 都会帮我们检测处理。 ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:5","tags":["Python","FastApi"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"可选字段 FastApi 的可选字段有以下两种场景 字段有默认值时 字段类型为 Optional 时 ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:6","tags":["Python","FastApi"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"代码 from pydantic import BaseModel from typing import Optional class Mds(BaseModel): name: str age: int = 18 home: str height: Optional[str] @app.post('/models/') async def add_model(model:Mds): return model ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:7","tags":["Python","FastApi"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"接口测试 只携带必选参数 只携带必选参数只携带必选参数 \" 只携带必选参数 携带全部参数 携带全部参数携带全部参数 \" 携带全部参数 携带多余参数（多余参数会被忽略） 携带多余参数携带多余参数 \" 携带多余参数 缺少必选参数 缺少必选参数缺少必选参数 \" 缺少必选参数 结论 请求结构体的字段，可以多，不可缺少必选的。 请求体使用 我们在视图函数内部可以直接使用请求体的属性。 ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:8","tags":["Python","FastApi"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"代码 from pydantic import BaseModel from typing import Optional class Mds(BaseModel): name: str age: int = 18 home: str height: Optional[str] @app.post('/models/') async def add_model(Mds:Mds): ret = {} if Mds.name: ret.update({\"Name\":Mds.name}) if Mds.height: ret.update({\"height\":Mds.height}) return ret ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:9","tags":["Python","FastApi"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"接口测试 接口测试接口测试 \" 接口测试 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:10","tags":["Python","FastApi"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"何为查询参数 在 FastApi 中，声明不属于路径参数的其他函数参数时，它们将被自动解释为\"查询字符串\"参数。 示例代码 from fastapi import FastAPI import uvicorn app = FastAPI() goods=['xiaomi','apple','huawei','oppo'] @app.get('/goods/') async def get_goods(start:int = 0,end:int = 3): return goods[start:end] if __name__ == \"__main__\": uvicorn.run(app='main:app',host='0.0.0.0',reload=True,debug=True) ","date":"2021-07-03","objectID":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/:0:0","tags":["Python","FastApi"],"title":"FastApi-03-查询参数","uri":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"接口测试 带参数 结果结果 \" 结果 带部分参数 因为在后台的视图函数中，两个查询参数都有默认值，所以我们可以对个别参数进行修改后进行请求测试。 结果结果 \" 结果 使用默认参数 当我们在发送请求的时候，不携带查询参数，则后台在接收到请求后会使用默认参数进行处理。即使用start=1，end=3 结果结果 \" 结果 可选参数 在我们实际开发中，某些参数可能需要，也可能不需要，这个根据用户的需求来定。 ","date":"2021-07-03","objectID":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/:0:1","tags":["Python","FastApi"],"title":"FastApi-03-查询参数","uri":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"示例代码 @app.get('/name/{name}/age/{age}') async def get_userinfo(name:str,age:int,j:Optional[bool]=False): ret = {'Name':name} if j: ret.update({'Age':age}) return ret 可选参数 j 作为判断条件，默认不返回年龄 age，当 j 为真时就会返回年龄信息。 ","date":"2021-07-03","objectID":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/:0:2","tags":["Python","FastApi"],"title":"FastApi-03-查询参数","uri":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"接口测试 普通请求，默认不会返回年龄信息 结果结果 \" 结果 携带参数 j 进行请求，会返回年龄信息 结果结果 \" 结果 参数类型转换 如上，我们在携带参数 j 进行请求的时候其值为 True，FastApi 为我们提供了更为方便的方式，就是查询参数的类型转换，即当其值为任何真值时，都可完成请求处理。 ","date":"2021-07-03","objectID":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/:0:3","tags":["Python","FastApi"],"title":"FastApi-03-查询参数","uri":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"示例请求 在 j=1 时进行请求操作 结果结果 \" 结果 在 j=0 时进行请求操作 结果结果 \" 结果 必选的查询参数 在实际开发中，我们可能需要用户必须携带某个参数才能完成请求。 ","date":"2021-07-03","objectID":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/:0:4","tags":["Python","FastApi"],"title":"FastApi-03-查询参数","uri":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"代码 我们只需要给上面的代码加上一个参数 q 即可，其余工作 FastApi 都会帮我们完成。 @app.get('/name/{name}/age/{age}') async def get_userinfo(name:str,age:int,q:bool,j:Optional[bool]=False): ret = {'Name':name} if j: ret.update({'Age':age}) return ret ","date":"2021-07-03","objectID":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/:0:5","tags":["Python","FastApi"],"title":"FastApi-03-查询参数","uri":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"接口测试 当不带 q 参数进行请求 结果结果 \" 结果 提示查询参数 q 缺失 当带上 q 参数进行请求 结果结果 \" 结果 请求成功 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-03","objectID":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/:0:6","tags":["Python","FastApi"],"title":"FastApi-03-查询参数","uri":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"何为路径参数 顾名思义，路径参数就是 url 中带的请求参数，比如根据 id 查询信息。 例:自动大写首字母 ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:0","tags":["Python","FastApi"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"main.py ... @app.get('/format/{name}') async def fmt(name): new_name = name.title() return {'result':new_name} ... ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:1","tags":["Python","FastApi"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"启动服务后测试 访问：http://127.0.0.1:8765/format/phyger 效果效果 \" 效果 可以看到，功能已经实现！ ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:2","tags":["Python","FastApi"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"存在的问题 访问：http://127.0.0.1:8765/format/123 效果效果 \" 效果 虽然有结果返回，但是我们期望后台能够对请求参数的格式进行校验。请继续往下看。 默认的路径参数类型都是 str，所以 123 已经被转换成了 str 类型。 带格式的路径参数 当我们在处理数字的时候，我们不希望后台对非法类型的数据进行处理。 ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:3","tags":["Python","FastApi"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"老代码 ... @app.get('/format1/{num}') async def fmt1(num): print(type(num)) new_num = num+1 return {'result':new_num} ... ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:4","tags":["Python","FastApi"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"路径参数为 123 的结果 效果效果 \" 效果 Internal Server Error，因为后台将 123 当做 str 处理了，所以在进行计算的时候出错了。 ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:5","tags":["Python","FastApi"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"新代码 @app.get('/format1/{num}') async def fmt1(num:int): print(type(num)) new_num = num+1 return {'result':new_num} ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:6","tags":["Python","FastApi"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"路径参数为 123 的结果 结果结果 \" 结果 成功！ 路径参数和查询参数的区别 路径参数是归属 url 的部分，而查询参数是在 url 后面使用?进行连接的参数。通常我们会将某个模块数据结构主键部分使用路径参数表达，而对于这个对象的附加信息我们通常使用查询参数表达。 顾名思义，路径参数指导我们拿到对象概要信息，而查询参数能够帮助我们查询到对象的更多信息。 关于更多查询参数的内容，我们下节内容继续分享。 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:7","tags":["Python","FastApi"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"FastApi是什么 顾名思义，FastApi就是一个用于构建高性能api的web框架。 FastApi的特点 快速：比肩NodeJs和Go 高效：开发效率提升一倍多 少BUG：减少开发错误率 智能：自动补全 简单：易于学习 简短：代码简小精悍 健壮：生产级别可用 文档：自动生成交互式文档 标准化：基于OpenApi FastApi的安装 pip install fastapi[all] FastApi之hello world ","date":"2021-07-01","objectID":"/fastapi-01-%E5%88%9D%E8%AF%86/:0:0","tags":["Python","FastApi","Token"],"title":"FastApi-01-初识","uri":"/fastapi-01-%E5%88%9D%E8%AF%86/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"main.py from fastapi import FastAPI app = FastAPI() @app.get('/') async def root(): return {'message':'hello world!'} ","date":"2021-07-01","objectID":"/fastapi-01-%E5%88%9D%E8%AF%86/:0:1","tags":["Python","FastApi","Token"],"title":"FastApi-01-初识","uri":"/fastapi-01-%E5%88%9D%E8%AF%86/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"命令行启动 uvicorn.exe main:app --reload INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) INFO: Started reloader process [18784] using statreload INFO: Started server process [23504] INFO: Waiting for application startup. INFO: Application startup complete. 打开 http://127.0.0.1:8000 查看效果 helloworldhelloworld \" helloworld 可以看到，后台程序已经成功返回。 ","date":"2021-07-01","objectID":"/fastapi-01-%E5%88%9D%E8%AF%86/:0:2","tags":["Python","FastApi","Token"],"title":"FastApi-01-初识","uri":"/fastapi-01-%E5%88%9D%E8%AF%86/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"主函数启动 from fastapi import FastAPI import uvicorn app = FastAPI() @app.get('/') async def root(): return {'message':'hello world!'} if __name__ == \"__main__\": uvicorn.run(app='main:app',host='127.0.0.1',port=8765,reload=True,debug=True) 启动： python main.py 交互式的API文档 ","date":"2021-07-01","objectID":"/fastapi-01-%E5%88%9D%E8%AF%86/:0:3","tags":["Python","FastApi","Token"],"title":"FastApi-01-初识","uri":"/fastapi-01-%E5%88%9D%E8%AF%86/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"docs 浏览器访问：127.0.0.1:8765/docs docsdocs \" docs 展开看下接口详细信息 接口详细信息接口详细信息 \" 接口详细信息 点击右侧的Try it Try itTry it \" Try it 即可实现接口调试！ 完美！ ","date":"2021-07-01","objectID":"/fastapi-01-%E5%88%9D%E8%AF%86/:0:4","tags":["Python","FastApi","Token"],"title":"FastApi-01-初识","uri":"/fastapi-01-%E5%88%9D%E8%AF%86/"},{"categories":["Python","Python进阶","web开发","FastApi简明教程"],"content":"redoc 浏览器访问：127.0.0.1:8765/redoc redocredoc \" redoc FastApi和Flask的区别 经常看到有人把 FastAPI 和 Flask 放到一起比较，但是却没有意识到这完全是两种东西——前者是基于 Web 框架 Starlette 添加了 Web API 功能支持的（框架之上的）框架，而后者是和 Starlette 同类的通用 Web 框架，所以他两本就不是相同的东西，所以还是不要强行比较，选择适合自己的才是正确的。 至于说FastApi使用了asyncio而使得它的性能提升很大，在我看来没有网上介绍的那么夸张。因为在gevent的加持下，其他web框架也可以做到很高的并发，况且一般的服务都是会借助中间件和集群来实现高并发的，所以对于FastApi的高性能大家还是理性看待。感兴趣的同学可以去测试看看实际的结果。 本系列主要是介绍FastApi这个新的web框架，让大家能够对它有所了解，从而合理使用。 至此，FastApi的简单介绍结束。 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-01","objectID":"/fastapi-01-%E5%88%9D%E8%AF%86/:0:5","tags":["Python","FastApi","Token"],"title":"FastApi-01-初识","uri":"/fastapi-01-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"什么是 Vue 众所周知，Vue 是前端领域知名的渐进式框架。有了它，我们不用直接操作 DOM，Vue 为我们提供了很多优雅的操作 DOM 的接口。使用 Vue 进行前端工程开发已经成为相当一部分开发者的选择。 如何使用 Vue 和其他框架一样，Vue 也拥有 CDN 在线加速资源，初学，我建议使用在线 CDN 进行学习。 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:0:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"推荐的 Vue 的 CDN 资源 \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e 你只需要将如上代码复制粘贴到 HTML 的 head 部分即可。 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:1:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"Demo-1-模板渲染 此 Demo 实现通过 Vue 对 DOM 进行数据渲染。 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003e{{ messages }}\u003c/h1\u003e \u003c/div\u003e \u003cscript\u003e var app1 = new Vue ( { el: '#app', data: { messages: 'hello Vue!' } } ) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:2:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"页面效果 页面效果\" 页面效果 现在页面的模板对象已经被 Vue 渲染，数据和 DOM 进行了绑定，数据由 Vue 提供，那我们如何确认呢？ 我们可以在控制台对 Vue 对象的数据元素进行修改，查看 DOM 会不会同步变化。 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:2:1","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"执行命令 app1.messages='hello Phyger!' ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:3:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"修改前 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:4:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"修改后 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:5:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"Demo-2-实战 此实战利用数据渲染简单实现点击按钮，显示当前时间的功能。 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:6:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003e{{ messages }}\u003c/h1\u003e \u003cbutton v-on:click='sj'\u003e点我查看当前时间\u003c/button\u003e \u003c/div\u003e \u003cscript\u003e var app1 = new Vue ( { el: '#app', data: { messages: 'hello Vue!' }, methods:{ sj: function(){ this.messages='当前时间：' + new Date().toLocaleTimeString() } } } ) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:6:1","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"页面效果 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:6:2","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"点击按钮后的效果 页面效果\" 页面效果 再点击一次 页面效果\" 页面效果 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:6:3","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":null,"content":"Title 野生程序员 Major CloudNative、Python Email 463551098@qq.com More 公众号：Python研究所 扫码关注 ","date":"2021-06-11","objectID":"/about/:0:0","tags":null,"title":"关于博主","uri":"/about/"}]