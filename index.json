[{"categories":["Python进阶"],"content":"通常，当我们需要对对象的敏感属性或者不希望外部直接访问的属性进行私有化，但是某些时候我们又需要对这些私有属性进行修改，该怎么处理呢？ 1、几个概念 _a(前置单下划线)，这种属性仅表示约定的私有，非真正的私有。 __a(前置双下划线)，这种属性表示私有，无法在外部访问。 _a_(前后双下划线)，这种属性标识系统属性。(可选) a_(后置单下划线)，这种属性是为了避免和保留关键字冲突。(可选) 2、举个例子 ","date":"2021-07-15","objectID":"/python%E7%9A%84property%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84/:0:0","tags":["Python","装饰器"],"title":"Python的@property是干嘛的？","uri":"/python%E7%9A%84property%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84/"},{"categories":["Python进阶"],"content":"定义一个类： class Student(object): _sex='male' __age=0 执行：（私有属性无法在外部访问） \u003e\u003e\u003e stu = Student() \u003e\u003e\u003e stu._sex 'male' \u003e\u003e\u003e stu.__age Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e AttributeError: 'Student' object has no attribute '__age' \u003e\u003e\u003e 3、解决问题 从上面的类中我们可以看到，私有属性无法在类实例中访问，怎么办呢？当我们需要对类的私有属性__age进行查询和修改的时候，我们可以定义get_age和set_age去实现。 class Student(object): _sex='male' __age=0 def get_age(self): return self.__age def set_age(self,age): self.__age = age 执行： \u003e\u003e\u003e stu = Student() \u003e\u003e\u003e stu.get_age() 0 \u003e\u003e\u003e stu.set_age(18) \u003e\u003e\u003e stu.get_age() 18 \u003e\u003e\u003e 4、换个方法 但是上面的这种方式略显复杂，如果在私有属性较多的类中就不太适用了，所以我们期望寻求一种更简单的方式去解决这个问题，比如将这个私有属性转化为另一个属性。告诉你个好消息，Python已经帮我们实现了，这就是@property。 class Student(object): _sex='male' __age=0 def get_age(self): return self.__age def set_age(self,age): self.__age = age @property def age(self): return self.__age 执行： \u003e\u003e\u003e from payhlib import Student \u003e\u003e\u003e s = Student() \u003e\u003e\u003e s.age 0 \u003e\u003e\u003e s.set_age(19) \u003e\u003e\u003e s.age 19 \u003e\u003e 在上面我们将__age私有属性转换为了age属性，你可能会想，既然私有属性转换为了属性，那我们是不是可以直接修改它呢？答案是不行，因为property虽然将__age转换为了属性，但是其不具备setter功能，需要我们去添加。 \u003e\u003e\u003e from payhlib import Student \u003e\u003e\u003e s = Student() \u003e\u003e\u003e s.age 0 \u003e\u003e\u003e s.age=20 Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e AttributeError: can't set attribute \u003e\u003e\u003e 添加setter方法 class Student(object): _sex='male' __age=0 def get_age(self): return self.__age def set_age(self,age): self.__age = age @property def age(self): return self.__age @age.setter def age(self,value): self.__age=value 执行： \u003e\u003e\u003e from payhlib import Student \u003e\u003e\u003e s = Student() \u003e\u003e\u003e s.age 0 \u003e\u003e\u003e s.age=20 \u003e\u003e\u003e s.age 20 \u003e\u003e\u003e 到此，@peoperty分享完毕，关于它的实现原理你可以查看源码进行研究。 源码\" 源码 ","date":"2021-07-15","objectID":"/python%E7%9A%84property%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84/:1:0","tags":["Python","装饰器"],"title":"Python的@property是干嘛的？","uri":"/python%E7%9A%84property%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84/"},{"categories":["Python进阶"],"content":"什么是闭包 Python中的闭包是一个比较模糊的概念，有很多朋友都认为不好理解，但是随着深入学习，就会发现闭包无论如何都是需要去理解的，下面我将自己对闭包的理解进行阐述，希望能够对你有所帮助 ~ 我们可以将闭包理解为一种特殊的函数，这种函数由两个函数的嵌套组成，且称之为外函数和内函数，外函数返回值是内函数的引用，此时就构成了闭包。 闭包的格式 如下： def 外层函数(参数): def 内层函数(): print(\"内层函数执行\", 参数) return 内层函数 内层函数的引用 = 外层函数(\"传入参数\") 内层函数的引用() 外层函数中的参数，不一定要有，据情况而定，但是一般情况下都会有并在内函数中使用到 闭包的实例 如下： def outfunc(a): # 定义外函数 def infunc(b): # 定义内函数 return a*b # 内函数的返回值 return infunc # 外函数的返回值，返回内函数的对象 func_instance = outfunc(8) # 外函数的实例，是一个function对象 print(type(func_instance)) # 打印外函数实例的类型 res = func_instance(10) # 外函数实例的调用 print(res) 输出 ➜ test git:(master) ✗ python3 testpy.py \u003cclass 'function'\u003e 80 在上面的代码中，内函数直接使用了外函数的变量值，那如果想要在内函数中对外函数的变量值进行修改，怎么操作呢？ 修改外函数的变量值 想要修改外函数的变量值，需要用到nonlocal关键字。 def outfunc(a): def infunc(b): nonlocal a a = a*2 return a*b return infunc func_instance = outfunc(8) print(type(func_instance)) res = func_instance(10) print(res) 输出 ➜ test git:(master) ✗ python3 testpy.py \u003cclass 'function'\u003e 160 如上即可。 闭包的使用场景 Python中，闭包的主要用途就是用于装饰器的实现。后续讲解。 还有就是可以简化参数重复传递，比如： def add(a,b,c): print(a*b*c) add(1,2,1) add(1,2,2) add(1,2,3) add(1,2,4) add(1,2,5) 输出 ➜ test git:(master) ✗ python3 testpy.py 2 4 6 8 10 你会发现，a和b是固定不变的，我们怎么样才能减少a和b的传参，而只改变c的值呢？这个时候闭包就起到了作用。 def addNew(a,b): def addC(c): return a*b*c return addC func_ins = addNew(1,2) print(func_ins(1)) print(func_ins(2)) print(func_ins(3)) print(func_ins(4)) print(func_ins(5)) 输出 ➜ test git:(master) ✗ python3 testpy.py 2 4 6 8 10 ","date":"2021-07-15","objectID":"/%E9%97%AD%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88/:0:0","tags":["Python","装饰器","闭包"],"title":"Python的闭包是什么？","uri":"/%E9%97%AD%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88/"},{"categories":["Python进阶"],"content":"基本的魔法方法 名称 解释 _new_(cls[, …]) 在一个对象实例化的时候所调用的第一个方法 _init_(self[, …]) 构造器，当一个实例被创建的时候调用的初始化方法 _del_(self) 析构器，当一个实例被销毁的时候调用的方法 _call_(self[, args…]) 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.call(a, b) _len_(self) 定义当被 len() 调用时的行为 _repr_(self) 定义当被 repr() 调用时的行为 _str_(self) 定义当被 str() 调用时的行为 _bytes_(self) 定义当被 bytes() 调用时的行为 _hash_(self) 定义当被 hash() 调用时的行为 _bool_(self) 定义当被 bool() 调用时的行为，应该返回 True 或 False _format_(self, format_spec) 定义当被 format() 调用时的行为 有关属性 名称 解释 _getattr_(self, name) 定义当用户试图获取一个不存在的属性时的行为 _getattribute_(self, name) 定义当该类的属性被访问时的行为 _setattr_(self, name, value) 定义当一个属性被设置时的行为 _delattr_(self, name) 定义当一个属性被删除时的行为 _dir_(self) 定义当 dir() 被调用时的行为 _get_(self, instance, owner) 定义当描述符的值被取得时的行为 _set_(self, instance, value) 定义当描述符的值被改变时的行为 _delete_(self, instance) 定义当描述符的值被删除时的行为 比较操作符 名称 解释 _lt_(self, other) 定义小于号的行为：x \u003c y 调用 x.lt(y) _le_(self, other) 定义小于等于号的行为：x \u003c= y 调用 x.le(y) _eq_(self, other) 定义等于号的行为：x == y 调用 x.eq(y) _ne_(self, other) 定义不等号的行为：x != y 调用 x.ne(y) _gt_(self, other) 定义大于号的行为：x \u003e y 调用 x.gt(y) _ge_(self, other) 定义大于等于号的行为：x \u003e= y 调用 x.ge(y) 算数运算符 名称 解释 _add_(self, other) 定义加法的行为：+ _sub_(self, other) 定义减法的行为：- _mul_(self, other) 定义乘法的行为：* _truediv_(self, other) 定义真除法的行为：/ _floordiv_(self, other) 定义整数除法的行为：// _mod_(self, other) 定义取模算法的行为：% _divmod_(self, other) 定义当被 divmod() 调用时的行为 _pow_(self, other[, modulo]) 定义当被 power() 调用或 ** 运算时的行为 _lshift_(self, other) 定义按位左移位的行为：« _rshift_(self, other) 定义按位右移位的行为：» _and_(self, other) 定义按位与操作的行为：\u0026 _xor_(self, other) 定义按位异或操作的行为：^ _or_(self, other) 定义按位或操作的行为： 反运算 名称 解释 _radd_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rsub_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rmul_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rtruediv_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rfloordiv_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rmod_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rdivmod_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rpow_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rlshift_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rrshift_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rand_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rxor_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _ror_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） 增量赋值运算 名称 解释 _iadd_(self, other) 定义赋值加法的行为：+= _isub_(self, other) 定义赋值减法的行为：-= _imul_(self, other) 定义赋值乘法的行为：*= _itruediv_(self, other) 定义赋值真除法的行为：/= _ifloordiv_(self, other) 定义赋值整数除法的行为：//= _imod_(self, other) 定义赋值取模算法的行为：%= _ipow_(self, other[, modulo]) 定义赋值幂运算的行为：**= _ilshift_(self, other) 定义赋值按位左移位的行为：«= _irshift_(self, other) 定义赋值按位右移位的行为：»= _iand_(self, other) 定义赋值按位与操作的行为：\u0026= _ixor_(self, other) 定义赋值按位异或操作的行为：^= _ior_(self, other) 定义赋值按位或操作的行为： 一元操作符 名称 解释 _pos_(self) 定义正号的行为：+x _neg_(self) 定义负号的行为：-x _abs_(self) 定义当被 abs() 调用时的行为 _invert_(self) 定义按位求反的行为：~x 类型转换 名称 解释 _complex_(self) 定义当被 complex() 调用时的行为（需要返回恰当的值） _int_(self) 定义当被 int() 调用时的行为（需要返回恰当的值） _float_(self) 定义当被 float() 调用时的行为（需要返回恰当的值） _round_(self[, n]) 定义当被 round() 调用时的行为（需要返回恰当的值） _index_(self) 1. 当对象是被应用在切片表达式中时，实现整形强制转换 2. 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 index 3. 如果 index 被定义，则 int 也需要被定义，且返回相同的值 上下文管理（with 语句） 名称 解释 _enter_(self) 1. 定义当使用 with 语句时的初始化行为 2. enter 的返回值被 with 语句的目标或者 as 后的名字绑定 _exit_(self, exc_type, exc_value, traceback) 1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么 2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 容器类型 名称 解释 _len_(self) 定义当被 len() 调用时的行为（返回容器中元素的个数） _getitem_(self, key) 定义获取容器中指定元素的行为，相当于 self[key] _setitem_(self, key, value) 定义设置容器中指定元素的行为，相当于 self[key] = value _delitem_(self, key) 定义删除容器中指定元素的行为，相当于 del self[key] _iter_(self) 定义当迭代容器中的元素的行为 _reversed_(self) 定义当被 reversed() 调用时的行为 _contains_(self, item) 定义当使用成员测试运算符（in 或 not in）时的行为 ","date":"2021-07-15","objectID":"/%E5%B9%B2%E8%B4%A7python%E7%9A%84%E9%AD%94%E6%95%B0%E6%96%B9%E6%B3%95%E4%B8%80%E8%A7%88%E8%A1%A8/:0:0","tags":["Python","魔法方法"],"title":"Python的魔法方法一览表","uri":"/%E5%B9%B2%E8%B4%A7python%E7%9A%84%E9%AD%94%E6%95%B0%E6%96%B9%E6%B3%95%E4%B8%80%E8%A7%88%E8%A1%A8/"},{"categories":["Python进阶"],"content":"接【简明】彻底搞清楚Python的装饰器，我们继续介绍类装饰器+带参数的装饰+多装饰器，顾名思义类装饰器就是类闭包。 定义一个类装饰器 需求：实现一个类装饰器，能够在方法执行时打印日志，并且发送通知到指定地方。 from functools import wraps class logAndNotify(object): # 初始化，定义日志路径 def __init__(self,logfile='service.log'): self.logfile = logfile # 使类成为可调用对象 def __call__(self,func): @wraps(func) def wrap_func(*args,**kwargs): info = func.__name__+'was called' # 实现写日志 with open(self.logfile,'a') as f: f.write(info+'\\n') # 实现通知 self.notify() return func(*args,**kwargs) return wrap_func def notify(self): print('notify has been send...') @logAndNotify() def sayHi(name): print('hello',name,'!') res = sayHi('phyger') print(res) 执行结果： ➜ RemoteWorking git:(master) ✗ /usr/bin/python3 /root/RemoteWorking/test/test.py notify has been send... hello phyger ! None 类装饰器功能扩展 如果我们想要在此类装饰器的基础上，增加发送邮件的功能，就可以利用类的继承特性来实现。 from functools import wraps class logAndNotify(object): # 初始化，定义日志路径 def __init__(self, logfile=\"service.log\"): self.logfile = logfile # 使类成为可调用对象 def __call__(self, func): @wraps(func) def wrap_func(*args, **kwargs): info = func.__name__ + \"was called\" # 实现写日志 with open(self.logfile, \"a\") as f: f.write(info + \"\\n\") # 实现通知 self.notify() return func(*args, **kwargs) return wrap_func def notify(self): print(\"notify has been send...\") class NewWarp(logAndNotify): # 初始化邮件地址 def __init__(self, email_address='phyger@qq.com', *args, **kwargs): self.email_address = email_address super(NewWarp,self).__init__(*args, **kwargs) # 重写notify方法 def notify(self): print(\"notify has been send...\") print('email sended...to',self.email_address) @NewWarp() def sayHi(name): print(\"hello\", name, \"!\") res = sayHi(\"phyger\") print(res) 执行结果： ➜ RemoteWorking git:(master) ✗ /usr/bin/python3 /root/RemoteWorking/test/test.py notify has been send... email sended...to phyger@qq.com hello phyger ! None 带参数的装饰器 当我们需要根据不同的场景对函数进行不同的装饰操作的时候，我们需要使用到带参数的装饰器。 例：日志级别控制 import logging from functools import wraps def logg(level): def mid(func): @wraps(func) def inner(*args, **kwargs): # log设置 #logging.basicConfig(format=' %(asctime)s - %(levelname)s -%(message)s') logging.basicConfig(format = '\"%(asctime)s- %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s\"') logger = logging.getLogger() logger.setLevel(level) # logger打印 logger.info('{} start...'.format(func.__name__)) logger.error('{} errors...'.format(func.__name__)) logger.warn('{} warnning...'.format(func.__name__)) logger.debug('{}end...'.format(func.__name__)) return func(*args, **kwargs) return inner return mid @logg(level='DEBUG') def sayHi(name): print('hi,',name) @logg(level='INFO') def sayBye(name): print('bye',name) sayHi(name='phyger') sayBye(name='phyger') 执行输出： ➜ RemoteWorking git:(master) ✗ /usr/bin/python3 /root/RemoteWorking/test/test.py \"2020-10-31 11:23:42,161 - test.py[line:15] - INFO: sayHi start...\" \"2020-10-31 11:23:42,161 - test.py[line:16] - ERROR: sayHi errors...\" \"2020-10-31 11:23:42,162 - test.py[line:17] - WARNING: sayHi warnning...\" \"2020-10-31 11:23:42,162 - test.py[line:18] - DEBUG: sayHiend...\" hi, phyger \"2020-10-31 11:23:42,162 - test.py[line:15] - INFO: sayBye start...\" \"2020-10-31 11:23:42,162 - test.py[line:16] - ERROR: sayBye errors...\" \"2020-10-31 11:23:42,162 - test.py[line:17] - WARNING: sayBye warnning...\" bye phyger 可以看到： 当设置最高级别ERROR的时候，所有级别的日志都打印。 当设置INFO级别的的时候，DEBUG最低级别的日志不打印。 多装饰器 当有多个不能够耦合的功能需要在函数上增加时，我们需要使用多个装饰器，怎么用呢？ 例：实现日志和发送通知的分离 import logging from functools import wraps def wrap1(func): def inner1(*args, **kwargs): print('start') func(*args, **kwargs) print('end') return True return inner1 def wrap2(func): def inner2(*args, **kwargs): print(\"msg has sended...\") func(*args, **kwargs) return True return inner2 @wrap1 @wrap2 def sayHi(name): print('hi',name) sayHi(name='phyher') 执行输出： ➜ RemoteWorking git:(master) ✗ /usr/bin/python3 /root/RemoteWorking/test/test.py start msg has sended... hi phyher end ","date":"2021-07-15","objectID":"/%E9%80%8F%E5%BD%BBpython%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%9B%E9%98%B6%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8-%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8-%E5%A4%9A%E8%A3%85%E9%A5%B0%E5%99%A8/:0:0","tags":["Python","装饰器"],"title":"Python装饰器进阶（类装饰器+带参数的装饰器+多装饰器）","uri":"/%E9%80%8F%E5%BD%BBpython%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%9B%E9%98%B6%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8-%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8-%E5%A4%9A%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["FastApi简明教程"],"content":"什么是 token token（也称令牌）就是一串字符，其作用是为了减轻频繁进行用户名和密码的验证而对服务器产生的压力。客户端首次访问通过正确的用户名和密码从服务端拿到 token，之后客户端携带 token 即可完成验证，无需重复携带用户名和密码。 ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:0","tags":["Python","FastApi","Token","后台开发"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"JWT JWT 全名 json web token，它是一种开放的标准，其带有数字签名，用于 json 对象的安全传输。 怎么生成 token 我们已经知道 token 是一串字符，我们可以通过一些秘钥+用户名+时间戳等字符组合，使用 base64 对其进行加密，从而生成 token 颁发给客户端。然后对客户端携带的 token 进行解密，拿到秘钥，用户名，时间戳，最后对这些参数进行校验就可以判断 token 正确与否和是否过期。 以上为 token 生成的原理，在实际开发中，我们可以直接使用现成的第三方库（如：python-jose）。 ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:1","tags":["Python","FastApi","Token","后台开发"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"常用的 JWT 库 python-jose pyjwt jwcrypto authlib ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:2","tags":["Python","FastApi","Token","后台开发"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"安装 JWT 库 pip install python-jose ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:3","tags":["Python","FastApi","Token","后台开发"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"生成 token # 从jose导入jwt，后面使用jwt生成token from jose import jwt # 导入日期模块，用来验证token过期时间 from datetime import datetime,timedelta # 定义秘钥，很重要，请勿泄露 SECRET_KEY = 'phyger' # 生成token的代码，token过期时长定义为默认参数，单位为秒 def create_token(seconds=60): # 定义token过期时间，为当前utc时间加上token有效期 expire = datetime.utcnow()+timedelta(seconds=seconds) # 此处即为生成token的payload，sub自定义（可选用户名），uid自定义（可选设备id等） # to_endoe可以是一个空的字典，但是不建议这样做 to_encode = {\"exp\":expire,\"sub\":SECRET_KEY,\"uid\":\"123456\"} # 使用jwt生成token，token是根据payload和秘钥共同生成。 jwt_token = jwt.encode(claims=to_encode,key=SECRET_KEY) return jwt_token jose 的 JWT 默认采用 HS256 加密方式。 运行代码 \u003e python utm.py eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MTI1MjY0OTgsInN1YiI6InBoeWdlciIsInVpZCI6IjEyMzQ1NiJ9.TnRFBFX_2Jn3VU26n603l5uOQyB9bOOWSxBQUr6tBA4 可以看到，token 已经生成。 上面，我们已经介绍了 token 的生成，是直接使用的第三方库 jose，当然 jose 可以生成 token，想必他也可以校验 token 了。 token 校验 ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:4","tags":["Python","FastApi","Token","后台开发"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"代码 from jose import jwt # 导入token校验的两种异常，一种是token超时异常，一种是token错误异常 from jose.exceptions import ExpiredSignatureError, JWTError def judge_token(token): # 尝试解密，解密成功后，秘钥，payload，有效时长校验通过，则会返回payload try: payload = jwt.decode(token,SECRET_KEY) print(payload) return True # 否则，则捕获异常，进行提示 except ExpiredSignatureError as e: print('token过期了！') return False except JWTError as e: print('token验证失败！') return False 按照传统的 jwt 协议，我们需要解密 token 后，对 token 的秘钥，payload，有效时长进行单独的校验。以上，token 的秘钥，payload，有效时长，jose 都帮我们完成了，我们只需要调用 jose.jwt 的 encode 和 deode 就可以完成加解密。 ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:5","tags":["Python","FastApi","Token","后台开发"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"执行校验 if __name__ == \"__main__\": tk=create_token() print(tk) res1=judge_token(tk) print(res1) import time time.sleep(60) res2=judge_token(tk) print(res2) 执行结果 \u003e python utm.py eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MTI1Mjg0MzYsInN1YiI6InBoeWdlciIsInVpZCI6IjEyMzQ1NiJ9.yVhoAKyZFvQi3q4wqd1JoRondl9A6wUaALueP00oyhc {'exp': 1612528436, 'sub': 'phyger', 'uid': '123456'} True token过期了！ False``` \u003e 因为默认token的有效期为60秒，我们在第二次校验token前睡眠了61秒，所以第二次的校验结果为过期！ **使用错误的token校验** ```python if __name__ == \"__main__\": res=judge_token('phyger666') print(res) 以上就是本篇的全部内容了，感谢您的阅读，我们再会。 ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:6","tags":["Python","FastApi","Token","后台开发"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"前言 通常，我们的接口都是需要认证后才能可以访问的，前面我们介绍了 token 的生成和校验，那在 FastApi 中怎么设计需要认证的接口呢？ 定义令牌对象 oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/token/\") 以上/token/为获取 token 的 URI，具体内容如下： class Token(BaseModel): access_token: str token_type: str @app.post('/token/',response_model=Token) async def get_token(response:Response,form_data: OAuth2PasswordRequestForm = Depends()): if form_data.username=='phyger' and form_data.password=='phyger666': response.headers['access_token']=create_token() return {\"access_token\":create_token(),\"token_type\":\"bearer\"} /token/可以返回指定格式的令牌信息。 定义需要认证的接口 @app.get('/format/{name}') async def fmt(name,token=Depends(oauth2_scheme)): print(token) print(type(name)) new_name = name.title() return {'result':new_name} ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:0","tags":["Python","FastApi","Token","后台开发"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["FastApi简明教程"],"content":"直接访问此接口 \" 如上，直接访问会提示未认证，这样，我们已经达到了目的，但是怎么样才能实现准确无误的认证呢？ ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:1","tags":["Python","FastApi","Token","后台开发"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["FastApi简明教程"],"content":"带上 bearer token 试试 \" 你会发现，我们携带的错误的 token 也能成功，这是为什么呢？ 因为在接口中，我们通过 oauth2_scheme 拿到了 token，这个 token 是标准的 bearer 格式，但是我们没有对其进行校验，所以只要格式正确，接口都能正常返回。 ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:2","tags":["Python","FastApi","Token","后台开发"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["FastApi简明教程"],"content":"使用错误的 bearer 格式 \" 如上，使用错误的 bearer 格式的 token，就无法访问接口了。 获取和校验 token 思路：通过上面的代码，我们将获取 token，校验 token 封装成一个静态方法，在需要认证的接口中对这个方法进行依赖即可。 ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:3","tags":["Python","FastApi","Token","后台开发"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["FastApi简明教程"],"content":"封装的接口 from utm import judge_token def login_required(token=Depends(oauth2_scheme)): credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"认证失败！\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) if judge_token(token=token): return True else: raise credentials_exception ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:4","tags":["Python","FastApi","Token","后台开发"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["FastApi简明教程"],"content":"需要认证的接口 @app.get('/format/{name}') async def fmt(name,token=Depends(login_required)): print(token) print(type(name)) new_name = name.title() return {'result':new_name} ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:5","tags":["Python","FastApi","Token","后台开发"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["FastApi简明教程"],"content":"直接访问/format/{name}接口 \" 提示：未认证！ ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:6","tags":["Python","FastApi","Token","后台开发"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["FastApi简明教程"],"content":"携带过期的 token 访问 \" 提示：认证失败！ ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:7","tags":["Python","FastApi","Token","后台开发"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["FastApi简明教程"],"content":"使用错误 bearer 格式 \" 提示：未认证！ ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:8","tags":["Python","FastApi","Token","后台开发"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["FastApi简明教程"],"content":"使用正确有效的 token \" 如上，成功！ 上面，我们将 token 错误，token 过期都统一定义为认证失败！后续可以进行细化。还需要考虑 token 续签的实现。 ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:9","tags":["Python","FastApi","Token","后台开发"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python进阶"],"content":"什么是装饰器 接“闭包”是什么？，我们可以认为装饰器就是一个闭包函数，同时它也返回了一个函数。 你也可以认为装饰器就是将函数作为参数传递到方法中，进行加工，再返回出来。 装饰器的使用场景 1、附加功能（统一日志格式，定时器） 2、数据的清理和添加（注入类似动态token的数据，修改清理内部数据） 3、函数注册等 装饰器的demo 1、实现函数在执行前后所花费的时间 装饰器的使用格式：@decorator # 定义装饰器 import time def execTime(func): def inner(*args,**kwargs): # 接收参数 time1 = time.time() res = func(*args,**kwargs) time2 = time.time() print(func.__name__,'执行花费',time2-time1,'s') return res # 返回func的返回值 return inner # 返回inner方法对象 # 在execAdd方法上使用execTime装饰器 @execTime def execAdd(a,b): time.sleep(1) return a+b # 调用execAdd res = execAdd(1,2) print(res) 运行结果： python3 test.py execAdd 执行花费 1.0000572204589844 s 3 2、实现日志的统一打印 import time,logging def execTime(func): def inner(*args,**kwargs): time1 = time.time() # 添加方法开始的日志 logging.warning('now func {} start...'.format(func.__name__)) res = func(*args,**kwargs) # 添加方法结束的日志 logging.warning('now func {} finished...'.format(func.__name__)) time2 = time.time() print(func.__name__,'执行花费',time2-time1,'s','\\n') return res return inner @execTime def execAdd(a,b): time.sleep(1) return a+b @execTime def sayHi(name): print('hello,{}.'.format(name)) sayHi('phyger') res = execAdd(1,2) print(res) 输出 python3 test.py WARNING:root:now func sayHi start... hello,phyger. WARNING:root:now func sayHi finished... sayHi 执行花费 0.00700068473815918 s WARNING:root:now func execAdd start... WARNING:root:now func execAdd finished... execAdd 执行花费 1.0020573139190674 s 3 你会看到上面的两个方法在执行前后都会被增加开始和结束的告警日志，而且会统计方法的执行时间，通过这种方式我们可以方便快捷的对方法进行封装。 注意 当我们执行以下代码时： @execTime def sayHi(name): print('hello,{}.'.format(name)) 输出 python3 test.py WARNING:root:now func sayHi start... hello,phyger. WARNING:root:now func sayHi finished... sayHi 执行花费 0.018001317977905273 s inner sayHi方法的name竟然是装饰器的内函数的方法，这不是我们的期望结果啊。我们方法的name和注释被装饰器内函数重写了，我们怎么解决这个问题呢？ Python帮我提供了一个函数来解决这个问题，他就是functools.wraps。 我们重写装饰器来看看效果： from functools import wraps import time,logging def execTime(func): @wraps(func) def inner(*args,**kwargs): time1 = time.time() logging.warning('now func {} start...'.format(func.__name__)) res = func(*args,**kwargs) logging.warning('now func {} finished...'.format(func.__name__)) time2 = time.time() print(func.__name__,'执行花费',time2-time1,'s','\\n') return res return inner # 调用 sayHi('phyger') print(sayHi.__name__) 输出 test.py WARNING:root:now func sayHi start... hello,phyger. WARNING:root:now func sayHi finished... sayHi 执行花费 0.003000020980834961 s sayHi 你能看到，使用了装饰器的sayHi方法的__name__值已经是它自身的值了。 如果你想在当前装饰器的基础上再增加功能，那么你可能需要使用类装饰器，因为类的继承特性可以很好的解决你这个需求。关于类装饰器我们后面再介绍。 ","date":"2021-07-15","objectID":"/%E7%AE%80%E6%98%8E%E5%BD%BB%E5%BA%95%E6%90%9E%E6%B8%85%E6%A5%9Apython%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/:0:0","tags":["Python","装饰器"],"title":"彻底搞清楚Python的装饰器","uri":"/%E7%AE%80%E6%98%8E%E5%BD%BB%E5%BA%95%E6%90%9E%E6%B8%85%E6%A5%9Apython%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["markdown"],"content":"背景 刚才在某群里无意间看到有位掘友提问：这个插入的图片怎么居中显示？其实我也早有这个疑问，只是懒得去处理。但是看到掘友有疑问，那作为热心肠的我必须帮他答疑解惑。 ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:0:0","tags":["markdown","掘金"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["markdown"],"content":"掘金原始居中方式 你会发现掘金原始的图片并不居中 尝试第1次 我们都知道，无论是Markdown还是富文本编辑器，最终在网页上的呈现方式都是一样的，无非是HTML+CSS+JS，通过以上简单的理论，我们开始第一次尝试，计划直接将Markdown的图片展示方式用HTML的\u003cimg\u003e标签替代。 ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:1:0","tags":["markdown","掘金"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["markdown"],"content":"代码 \u003cimg style=\"align:center\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58935071dcee4613bf27ec6e9bb10bc6~tplv-k3u1fbpfcp-watermark.image\" /\u003e ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:2:0","tags":["markdown","掘金"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["markdown"],"content":"效果 你会发现依然不居中，原因竟是直接在img标签中添加的样式竟然没有生效，证据如下。 尝试第2次 经过上面的失败，我们决定换一种方式，即直接使用style标签来定义样式。 ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:3:0","tags":["markdown","掘金"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["markdown"],"content":"代码 \u003cstyle type=\"text/css\"\u003e img {align:center} \u003c/style\u003e \u003cimg style=\"align:center\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58935071dcee4613bf27ec6e9bb10bc6~tplv-k3u1fbpfcp-watermark.image\" /\u003e ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:4:0","tags":["markdown","掘金"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["markdown"],"content":"效果 img {align:center} -_-// 简直没脸看啊，样式直接漏了。 尝试第3次 经过上面的失败，我决定了这次再不成功，我就弃笔从戎了！估计我这小身板儿也进不了部队，哈哈哈。这次我们计划用div包裹img标签，因为通常前端都是这么干的。 ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:5:0","tags":["markdown","掘金"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["markdown"],"content":"代码 \u003cdiv align=center\u003e \u003cimg src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58935071dcee4613bf27ec6e9bb10bc6~tplv-k3u1fbpfcp-watermark.image\" /\u003e \u003c/div\u003e ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:6:0","tags":["markdown","掘金"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["markdown"],"content":"效果 (#^.^#)，我去，终于成了。虽然这是很简单的基操，但是能够帮到掘友，我还是很开心的。 多说一句 通过这篇文章，我建议各位掘友能够动手去设计属于自己的主题并且贡献给社区，这样对于推动社区体验无疑是一件小但很好的事情。 以上就是本文的全部内容，如果喜欢记得（四连）：点赞，评论，收藏，转发。 ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:7:0","tags":["markdown","掘金"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["前端技术"],"content":"前言 相信很多同学在学习 Vue 的时候，会经常用到或者被问题到单向数据流和双向数据绑定的概念，那它两到底有什么区别呢？我们一起来看看。 单向数据流 单向数据流在 Vue 中实际表现就是：当 Model 中的 data 发生变化的时候会单向修改 View 中的值，而 View 中的值发生变化的时候，Model 不会感知。实际应用就是 v-bind 单向数据。 双向数据绑定 和单向数据流相比，双向数据绑定就是多了 View 变化会通知到 Model 层。即 MVVM 的具体实现。无论 Model 还是 View 中的值发生变化，都会通过 ViewModel 通知到对方，实现同步。实际应用就是 v-model 双向数据绑定。 代码 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003e单向\u0026双向\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003e单向数据流\u003c/h1\u003e 现在的时间是：{{ mytime }} \u003cbr\u003e \u003cbutton type=\"button\" @click=\"shuax\"\u003e刷新时间\u003c/button\u003e \u003cbr\u003e\u003cbr\u003e \u003chr \u003e \u003ch1\u003e双向数据绑定\u003c/h1\u003e \u003cinput v-model=\"sxbind\"/\u003e \u003cbr\u003e 你输入的数据是：{{ sxbind }} \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e app = new Vue({ el: '#app', data: { mytime:new Date().toLocaleTimeString(), sxbind:'' }, methods: { shuax:function(){ this.mytime = new Date().toLocaleTimeString(); } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 单向数据流效果 初始页面↑ 初始页面 \" 初始页面 点击刷新时间↑ 点击刷新时间（Model变化View也变） \" 点击刷新时间 Model变化View也变↑ Model变化View也变 \" Model变化View也变 View变化Model不变↑ View变化Model不变 \" View变化Model不变 双向数据绑定效果 Model变化View也变↑ Model变化View也变 \" Model变化View也变 Model变化View也变↑ View变化Model也变 \" Model变化View也变 总结 单向数据流是通过 props 将 Model 层的变化通知到 View 层进行修改。双向数据绑定是通过 Object.defineProperty()的 set() 和 get() 方法来实现的，当某一方发生变化的时候，另一方就会收到更新值的提醒，从而实现数据同步变化。 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-07-14","objectID":"/vue%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/:0:0","tags":["Vue","前端"],"title":"Vue的单向数据流和双向数据绑定","uri":"/vue%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"},{"categories":["FastApi简明教程"],"content":"什么是 Example 你可能注意到了，之前的 docs 中在 response 中的 Example Value 中是没有实例的，这个怎么做呢？ 答案是使用 Filed 对象，也可以在模型中使用 schema_extra。 Requests Example Value ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:0:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["FastApi简明教程"],"content":"Filed from pydantic import BaseModel,Field class ss(BaseModel): name:str = Field(...,example='phyger') age:int = Field(...,example=18) @app.post('/ff/') async def get_ff(ff:ss): res = {'res':ff} return res ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:1:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["FastApi简明教程"],"content":"docs docsdocs \" docs 可以看到，已经有了实例数据 ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:2:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["FastApi简明教程"],"content":"schema_extra from pydantic import BaseModel,Field class ss(BaseModel): name:str age:int class Config: schema_extra = { \"example\":{ \"name\":\"phyger678\", \"age\":20 } } @app.post('/ff/') async def get_ff(ff:ss): res = {'res':ff} return res ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:3:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["FastApi简明教程"],"content":"docs docsdocs \" docs 可以看到，效果已经展现出来了。 Response Example Value 搞定了 Requests 的示例信息，现在我们一起来研究下 Reponse 的示例信息。 ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:4:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["FastApi简明教程"],"content":"代码 from pydantic import BaseModel class info(BaseModel): name:str age:int @router.post('/test') def test(info:info): msg = {\"people_info\":info} return msg ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:5:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["FastApi简明教程"],"content":"效果 你会发现如上的代码在 docs 中是没有 Reponse 的示例信息的。 效果效果 \" 效果 ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:6:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["FastApi简明教程"],"content":"代码-New from pydantic import BaseModel class info(BaseModel): name:str age:int class repMd(BaseModel): people_info:info @router.post('/test',response_model=repMd) def test(info:info): msg = {\"people_info\":info} return msg ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:7:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["FastApi简明教程"],"content":"效果-New 你会发现，Reponse 的示例数据已经搞定。 效果效果 \" 效果 这样做有什么用呢？ 除了上面我们介绍的可以在 docs 中对接口进行信息的完善和请求体的提示以外。Example 部分还可以对整个项目的重构，以及系统对接，交付测试等起到意想不到的良好效果。 还是建议大家在实际开发过程中，能够添加 Requests 和 Reponse 的示例信息，磨刀不误砍柴工，只有在我们项目的初始阶段就定好规则，大家一起遵守，这样才能做出一个好的产品。 以上都是小编在实际工作中深切体会到的，如果前期没有完善的相关注释和文档，将会为后续的维护和测试等造成很大的困扰。返工的成本远比当时盲目赶工时取得的眼前收益大得多！ 做产品还是得脚踏实地，稳步前进！ 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-10","objectID":"/fastapi-10-docs%E7%9A%84example-value/:8:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-10-Docs的Example Value","uri":"/fastapi-10-docs%E7%9A%84example-value/"},{"categories":["FastApi简明教程"],"content":"什么是模板 简单理解，模板就是 web 后端向前端发送的 html 模型。 在前面的学习中，我们已经知道了关于 FastApi 的请求和参数的使用方法。但是我们在实际的 web 开发中，都会以网页的形式展现。那么在 FastApi 中我们也可以借助第三方的模板引擎来实现后端对网页模板的渲染。 注：大家都知道目前 web 项目大都采用比较主流的前后端分离模式。但是为了学习方便，我们先采用后端渲染的方式。 FastApi 的模板详解 ","date":"2021-07-10","objectID":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/:0:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-11-模板渲染","uri":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/"},{"categories":["FastApi简明教程"],"content":"关于引擎 FastApi 常用 Jinja2 模板引擎实现页面渲染。 虽然 FastApi 的 starlette 已经封装了 Jinja2 相关的类对象，但是你在使用中，仍然需要安装 jinja2 引擎。 这个地方很奇葩 普通渲染 ","date":"2021-07-10","objectID":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/:1:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-11-模板渲染","uri":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/"},{"categories":["FastApi简明教程"],"content":"项目结构 ","date":"2021-07-10","objectID":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/:2:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-11-模板渲染","uri":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/"},{"categories":["FastApi简明教程"],"content":"使用引擎 from fastapi import FastAPI # 导入Request上下文对象，用来在前后台之间传递参数 from starlette.requests import Request # 导入jinja2模板引擎对象，用于后续使用 from starlette.templating import Jinja2Templates app=FastAPI() # 实例化一个模板引擎对象，指定模板所在路径 templates=Jinja2Templates(directory='templates') @app.get('/index/{info}') # 在视图函数中传入request对象，用于在模板对象中传递上下文（同时接收路径参数info，将其传递到上下文中） async def index(request:Request,info:str): # 返回一个模板对象，同时使用上下文中的数据对模板进行渲染 return templates.TemplateResponse(name='index.html',context={'request':request,'info':info}) if __name__ == '__main__': import uvicorn uvicorn.run(app='main:app',host='127.0.0.1',port=8765,reload=True) ","date":"2021-07-10","objectID":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/:3:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-11-模板渲染","uri":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/"},{"categories":["FastApi简明教程"],"content":"index.html 内容 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eFastApi\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eIndex\u003c/h1\u003e \u003ch1\u003eINFO:{{ info }}\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-07-10","objectID":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/:4:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-11-模板渲染","uri":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/"},{"categories":["FastApi简明教程"],"content":"浏览器中的效果 http://127.0.0.1:8765/index/phyger 如上，我们简单的展示了如何使用 FastApi 进行模板的渲染。 循环渲染 ","date":"2021-07-10","objectID":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/:5:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-11-模板渲染","uri":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/"},{"categories":["FastApi简明教程"],"content":"视图代码 我们将循环渲染的视图放到了 FastApi 的 Router（路由）中。 @router.get('/indexs') # 在视图函数中传入request对象，用于在模板对象中传递上下文（同时接收路径参数info，将其传递到上下文中） async def index(request:Request): # 定义一个列表 info = [\"phyger\",\"python\",\"go\"] # 返回一个模板对象，同时使用上下文中的数据对模板进行渲染 return templates.TemplateResponse(name='index.html',context={'request':request,'info':info}) ","date":"2021-07-10","objectID":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/:6:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-11-模板渲染","uri":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/"},{"categories":["FastApi简明教程"],"content":"页面代码 \u003cbody\u003e \u003ch1\u003eInfo\u003c/h1\u003e \u003cb\u003e| 后面的reverse是用反转顺序的。\u003c/b\u003e \u003col\u003e {% for msg in info|reverse %} \u003cli\u003e{{ msg }}\u003c/li\u003e {% else %} \u003cli\u003e沒有任何值\u003c/li\u003e {% endfor %} \u003c/ol\u003e \u003ch1\u003e{{ info }}\u003c/h1\u003e \u003c/body\u003e ","date":"2021-07-10","objectID":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/:7:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-11-模板渲染","uri":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/"},{"categories":["FastApi简明教程"],"content":"页面效果 由于我们在 jinja 模板中对循环结果进行了反转，所以列表的顺序和原始的列表数据是相反的。 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-10","objectID":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/:8:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-11-模板渲染","uri":"/fastapi-11-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/"},{"categories":["FastApi简明教程"],"content":"常用基础嵌套 使用 FastAPI，你可以定义、校验、记录文档并使用任意深度嵌套的模型（归功于 Pydantic）。 ","date":"2021-07-09","objectID":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/:0:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-09-模型嵌套","uri":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/"},{"categories":["FastApi简明教程"],"content":"基础模型 class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None tags: list = [] ","date":"2021-07-09","objectID":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/:0:1","tags":["Python","FastApi","后台开发"],"title":"FastApi-09-模型嵌套","uri":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/"},{"categories":["FastApi简明教程"],"content":"定义类型的字类型 假设我们需要制定一个字段 tags:list 的元素都为 str 类型，怎么做呢？ 答案是：使用 typing 中的 List 类。（指定其他字类型亦是如此） from typing import List tags: List[str] 如上，就定义了一个元素类型为 str 的列表。 嵌套模型 为了方便组合拆解，我们可以将某些模型对象单独声明，然后在其他模型中引用。 class Image(BaseModel): url: str name: str class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None tags: Set[str] = [] image: Optional[Image] = None 如上，我们定义了一个 Image 模型，在 Item 模型中直接使用了。 在实际请求时，我们按照以下格式发送请求体即可。 { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2, \"tags\": [\"rock\", \"metal\", \"bar\"], \"image\": { \"url\": \"http://example.com/baz.jpg\", \"name\": \"The Foo live\" } } 特殊类型 HttpUrl：由 pydantic 提供。 class Image(BaseModel): url: HttpUrl name: str 以上的使用方式，FastApi 支持自动联想补全，数据转换，数据校验，文档自动生成等。 实践 ","date":"2021-07-09","objectID":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/:0:2","tags":["Python","FastApi","后台开发"],"title":"FastApi-09-模型嵌套","uri":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/"},{"categories":["FastApi简明教程"],"content":"基础类型 class Md1(BaseModel): name:str age:int @app.post('/model/1') async def m1(md:Md1): return {'msg':'model is ok!'} 执行测试： 测试结果测试结果 \" 测试结果 根据测试结果，我们可以知道：①FastApi 的模型检验功能很好用。② 当整数被双引号包裹，FastApi 可以根据其限定的类型自动转换。③ 对于数据结构检验有明确的提示。 ","date":"2021-07-09","objectID":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/:1:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-09-模型嵌套","uri":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/"},{"categories":["FastApi简明教程"],"content":"嵌套类型 class Md1(BaseModel): name:str age:int class Md2(BaseModel): city_info:str people_info:Md1 @app.post('/model/1') async def m1(md:Md1): return {'msg':'model is ok!'} @app.put('/model/2') async def m2(md:Md2): return {'msg':'relation model cheking pass!'} 执行测试： 测试结果测试结果 \" 测试结果 根据以上测试结果，我们可以清晰的了解到 FastApi 借助 pydantic 实现的模型嵌套非常优雅。模型嵌套结合动态请求体，我们可以很方便的应对业务变化导致的数据模型变化。 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-09","objectID":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/:2:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-09-模型嵌套","uri":"/fastapi-09-%E6%A8%A1%E5%9E%8B%E5%B5%8C%E5%A5%97/"},{"categories":["FastApi简明教程"],"content":"背景 和查询参数一样，路径参数也需要进行限定。 Path 通常，我们会直接使用 name:str='phyger'的方式来限定路径参数的类型和默认值，但是对于路径参数的高级元数据，我们需要借助 FastApi 为我们提供的 Path 对象来实现。 通常路径参数时必须的，所以即便你指定了默认参数，其依然是必须的。 ","date":"2021-07-08","objectID":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-08-路径参数校验","uri":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"路径参数的 title from fastapi import Path @app.get('/path/{name}') async def pth(name:str=Path(...,title='path name')): return {'path_name':name} ","date":"2021-07-08","objectID":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:1:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-08-路径参数校验","uri":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"限定路径参数的格式 数值校验 大于2：gt=2 小于2：lt=2 大于等于2：ge=2 小于等于2：le=2 from fastapi import Path @app.get('/path/{name}') async def pth(* ,name:int=Path(...,title='path name',ge=2),q:str): return {'path_name':name} PathPath \" Path ","date":"2021-07-08","objectID":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:2:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-08-路径参数校验","uri":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"路径参数的顺序问题 当我们的业务模型中有两个uri，一个路径参数是固定值，另一个是路径参数是变量，该如何处理呢？ 假设当前业务中的视图有如下两条： @app.get('/path/{name}') async def pth(name:str=Path(...,title='path name')): return {'path_name':name} @app.get('/path/default') async def f1(): return {'msg':'I am default path.'} 分析以上代码，当我们请求/path/default的时候，我们会得到{'msg':'I am default path.'}的结果。 测试一下： 结果结果 \" 结果 这是怎么回事？和我预期的不一致。 这是因为代码中的两个uri冲突了，对于/path/default而言，/path/{name}已经拦截了所有符合/path/xxx的请求。我们只要将他两的顺序调整为固前变后（固定路径参数在前，变化路径参数在后）即可。 ","date":"2021-07-08","objectID":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:3:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-08-路径参数校验","uri":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"修改的代码 @app.get('/path/default') async def f1(): return {'msg':'I am default path.'} @app.get('/path/{name}') async def pth(name:str=Path(...,title='path name')): return {'path_name':name} 再次测试： 测试结果测试结果 \" 测试结果 可以看到，/path/default已经成功拦截并返回正确的结果。 再测试下非固定参数的功能： 非固定参数非固定参数 \" 非固定参数 可以看到，我们的非固定路径参数的其他功能均正常。 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-08","objectID":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:3:1","tags":["Python","FastApi","后台开发"],"title":"FastApi-08-路径参数校验","uri":"/fastapi-08-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"问题抛出 前面我们已经了解了查询参数，但是实际开发中我们可能需要限定参数的类型，长度等其他属性。这个时候我们就需要对查询参数进行校验。 类型我们可以通过显示类型进行限制，但是长度等其他属性我们需要借助 FastApi 的 Query 对象来实现。 实例 ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"实现方式 参数限定，我们需要借助 fastapi 中的 Query 对象来实现。 导入 Query from fastapi import Query ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:1","tags":["Python","FastApi","后台开发"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"限定参数最大长度 使用参数：max_length @app.get('/len') async def get_len(q:str=Query(...,max_length=2)): res = {'name':'phyger'} if q: res.update({'q':q}) return res max_lengthmax_length \" max_length 从以上测试可知： 查询参数 q 为可选参数、最大长度为 2，超过最大长度 fastapi 将会报错。 ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:2","tags":["Python","FastApi","后台开发"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"限定参数最小长度 使用参数：min_length @app.get('/len') async def get_len(q:Optional[str]=Query(None,min_length=2,max_length=5)): res = {'name':'phyger'} if q: res.update({'q':q}) return res min_lengthmin_length \" min_length Query 类型的查询参数必须制定默认值。形如：Query(...,min_length=2,max_length=5) 除了限定长度，我们还可以通过 regex 属性来通过正则表达式限定参数格式 ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:3","tags":["Python","FastApi","后台开发"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"默认查询参数 可选查询参数： 通常我们使用 Optional 类型结合 Query 类型的默认值来实现； async def get_len(q:Optional[str]=Query(None,min_length=2,max_length=5)): pass async def get_len(q:str=Query(None,min_length=2,max_length=5)): pass 以上两种方式都可。 必选查询参数： 通常我们指定 Query 的默认值为...来实现。 async def get_len(q:str=Query(...,min_length=2,max_length=5)): pass 当 Optional 类型和...默认参数同时存在的时候，查询参数依然为必选。 ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:4","tags":["Python","FastApi","后台开发"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"多个查询参数 当我们需要设计多个查询参数的时候，我们可以这样写。 from typing import List from fastapi import Query @app.get('/len') async def get_len(q:Optional[List[str]]=Query(...,min_length=2,max_length=5)): res = {'name':'phyger'} if q: res.update({'q':q}) return res 多查询参数多查询参数 \" 多查询参数 直接使用 list 也可以 from typing import List from fastapi import Query @app.get('/len') async def get_len(q:Optional[list]=Query(...)): res = {'name':'phyger'} if q: res.update({'q':q}) return res 多查询参数多查询参数 \" 多查询参数 更多的元数据 ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:5","tags":["Python","FastApi","后台开发"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"title Query 的 title 属性可以让我们指定参数的标题，用做提示。 from fastapi import Query @app.get('/title/') async def title(name:str = Query(...,title=\"test title\",max_length=5,min_length=2)): return {'result':name} ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:6","tags":["Python","FastApi","后台开发"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"description from fastapi import Query @app.get('/title/') async def title(name:str = Query(...,title=\"test title\",max_length=5,min_length=2,description='test desc')): return {'result':name} ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:7","tags":["Python","FastApi","后台开发"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"doc 中的效果 doc 中的效果doc 中的效果 \" doc 中的效果 ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:8","tags":["Python","FastApi","后台开发"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"别名 实际应用中，有时候查询参数可能形如 x-name，这在 python 中不是合法的变量，为了解决类似问题，FastApi 为我们提供了别名 alias 功能。 from fastapi import Query @app.get('/title/') async def title(name:str = Query(...,max_length=5,min_length=2,alias='x-name')): return {'result':name} 别名别名 \" 别名 ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:9","tags":["Python","FastApi","后台开发"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"参数弃用 当我们计划在后续版本中废弃参数时，我们可以通过 deprecated 属性来提示用户。 from fastapi import Query @app.get('/title/') async def title(name:str = Query(...,max_length=5,min_length=2,alias='x-name',deprecated=True)): return {'result':name} ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:10","tags":["Python","FastApi","后台开发"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"接口文档中的效果 接口文档中的效果接口文档中的效果 \" 接口文档中的效果 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-07","objectID":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/:0:11","tags":["Python","FastApi","后台开发"],"title":"FastApi-07-查询参数校验","uri":"/fastapi-07-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"categories":["FastApi简明教程"],"content":"动态请求体 诉求：当我们想要动态的向请求体中增加一个字段，但是不想修改原有的请求体数据模型，怎么办呢？ 答案是：使用动态请求体 Body 实例 ","date":"2021-07-06","objectID":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-06-请求体-3","uri":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["FastApi简明教程"],"content":"原有数据模型 class Mds(BaseModel): name: str age: int = 18 home: str height: Optional[str] class Mm(BaseModel): title: str phone: str = 'huawei' ","date":"2021-07-06","objectID":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:1","tags":["Python","FastApi","后台开发"],"title":"FastApi-06-请求体-3","uri":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["FastApi简明教程"],"content":"原有的视图函数 @app.put('/models/{name}') async def add_model(Mds:Mds,Mm:Mm,name:str,q: Optional[bool] = False): ret = {} if q: ret.update({\"request_name\":name}) if Mds.name: ret.update({\"Name\":Mds.name}) if Mds.height: ret.update({\"height\":Mds.height}) if Mm.title: ret.update({\"Title\":Mm.title}) return ret ","date":"2021-07-06","objectID":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:2","tags":["Python","FastApi","后台开发"],"title":"FastApi-06-请求体-3","uri":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["FastApi简明教程"],"content":"向请求体增加一个字段 此时，我们需要修改视图函数即可。 from fastapi import Body @app.put('/models/{name}') async def add_model(Mds:Mds,Mm:Mm,name:str,q: Optional[bool] = False,weight:str=Body(...)): ret = {} if q: ret.update({\"request_name\":name}) if Mds.name: ret.update({\"Name\":Mds.name}) if Mds.height: ret.update({\"height\":Mds.height}) if Mm.title: ret.update({\"Title\":Mm.title}) return ret ","date":"2021-07-06","objectID":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:3","tags":["Python","FastApi","后台开发"],"title":"FastApi-06-请求体-3","uri":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["FastApi简明教程"],"content":"接口测试 接口测试接口测试 \" 接口测试 如上图，我们已经成功实现动态增加请求体字段 注意 当请求体为单个模型时，动态字段和请求模型原字段同级。当请求体为多个模型时，动态字段和请求模型类名同级。 ","date":"2021-07-06","objectID":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:4","tags":["Python","FastApi","后台开发"],"title":"FastApi-06-请求体-3","uri":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["FastApi简明教程"],"content":"单个数据模型时的请求体 { \"Mds\": { \"name\": \"phyger\", \"home\": \"xian\", \"ok\": \"ok\", \"weight\": \"70kg\" } } ","date":"2021-07-06","objectID":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:5","tags":["Python","FastApi","后台开发"],"title":"FastApi-06-请求体-3","uri":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["FastApi简明教程"],"content":"多个数据模型时的请求体 { \"Mds\": { \"name\": \"phyger\", \"home\": \"xian\", \"ok\": \"ok\" }, \"Mm\": { \"title\": \"TSE\", \"phone\": \"xiaomi\" }, \"weight\": \"70kg\" } 对于请求体的介绍我们到这里就基本结束了，我们可以以此作为借鉴，在实际开发中多多实践，以充分感知请求体在开发中的作用。 附：常见的请求体类型 序号 类型 解释 1 multipart/form-data 以表单的形式上传文件 2 application/x-www-from-urlencoded 以键值对的数据格式提交，当action为post时，浏览器将form数据封装到http body中 3 raw 上传任意格式的文本（text，js，json，html，xml） 4 binary 以二进制的形式上传文件 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-06","objectID":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:6","tags":["Python","FastApi","后台开发"],"title":"FastApi-06-请求体-3","uri":"/fastapi-06-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["FastApi简明教程"],"content":"请求体+路径参数 实际开发中，我们经常会遇到请求体和路径参数同时存在的场景。 ","date":"2021-07-05","objectID":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-05-请求体-2","uri":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["FastApi简明教程"],"content":"代码 from pydantic import BaseModel class Mds(BaseModel): name: str age: int = 18 home: str height: Optional[str] @app.post('/models/{name}/') async def add_model(Mds:Mds,name:str): ret = {} ret.update({\"request_name\":name}) if Mds.name: ret.update({\"Name\":Mds.name}) if Mds.height: ret.update({\"height\":Mds.height}) return ret 如上，根据路径参数进行不同的响应。 ","date":"2021-07-05","objectID":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:1","tags":["Python","FastApi","后台开发"],"title":"FastApi-05-请求体-2","uri":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["FastApi简明教程"],"content":"接口测试 接口测试接口测试 \" 接口测试 请求体 + 路径参数 + 查询参数 ","date":"2021-07-05","objectID":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:2","tags":["Python","FastApi","后台开发"],"title":"FastApi-05-请求体-2","uri":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["FastApi简明教程"],"content":"代码 from pydantic import BaseModel class Mds(BaseModel): name: str age: int = 18 home: str height: Optional[str] @app.put('/models/{name}') async def add_model(Mds:Mds,name:str,q: Optional[bool] = False): ret = {} if q: ret.update({\"request_name\":name}) if Mds.name: ret.update({\"Name\":Mds.name}) if Mds.height: ret.update({\"height\":Mds.height}) return ret ","date":"2021-07-05","objectID":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:3","tags":["Python","FastApi","后台开发"],"title":"FastApi-05-请求体-2","uri":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["FastApi简明教程"],"content":"接口测试 接口测试接口测试 \" 接口测试 如上，FastApi 可以智能的，自动的识别各类型参数，并从正确的位置获取数据。 多结构体时的请求体 通常，为了方便结构体定义，我们可能会将不同类型的结构体分别定义在不同的数据模型中。这样，在视图函数的参数中，也将有多个模型参数，那具体怎么使用呢？ ","date":"2021-07-05","objectID":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:4","tags":["Python","FastApi","后台开发"],"title":"FastApi-05-请求体-2","uri":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["FastApi简明教程"],"content":"代码 from pydantic import BaseModel from typing import Optional class Mds(BaseModel): name: str age: int = 18 home: str height: Optional[str] class Mm(BaseModel): title: str phone: str = 'huawei' @app.put('/models/{name}') async def add_model(Mds:Mds,Mm:Mm,name:str,q: Optional[bool] = False): ret = {} if q: ret.update({\"request_name\":name}) if Mds.name: ret.update({\"Name\":Mds.name}) if Mds.height: ret.update({\"height\":Mds.height}) if Mm.title: ret.update({\"Title\":Mm.title}) return ret ","date":"2021-07-05","objectID":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:5","tags":["Python","FastApi","后台开发"],"title":"FastApi-05-请求体-2","uri":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["FastApi简明教程"],"content":"接口测试 接口测试接口测试 \" 接口测试 如上，当存在 Mds:Mds,Mm:Mm 两个结构体参数的时候，正确的请求体格式为：{\u003c模型类名\u003e:\u003c模型\u003e} { \"Mds\": { \"name\": \"phyger\", \"home\": \"xian\", \"ok\": \"ok\" }, \"Mm\": { \"title\": \"TSE\", \"phone\": \"xiaomi\" } } 对于结构体明确的请求体，我们可以参考本篇内容进行开发实践，那如果在进行代码重构或者业务调整的时候，请求体的数据结构发生了变化，应该如何应对呢？下篇文章我们继续探索！ 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-05","objectID":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/:0:6","tags":["Python","FastApi","后台开发"],"title":"FastApi-05-请求体-2","uri":"/fastapi-05-%E8%AF%B7%E6%B1%82%E4%BD%93-2/"},{"categories":["FastApi简明教程"],"content":"何为请求体 顾名思义，请求体就是在请求过程中客户端携带的数据。 请求体不是一定要携带的，而且请求体不建议用 GET 请求发送，通常我们会使用 POST 请求发送请求体，当然是用 PUT、DELETE、PATCH 方式也可以发送请求体。 举个栗子 根据请求体做相应的响应，如下返回请求体内容。 FastApi 的请求体需要为 dict 格式 ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["FastApi简明教程"],"content":"代码 @app.post('/models/') async def add_model(model:str): return model ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:1","tags":["Python","FastApi","后台开发"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["FastApi简明教程"],"content":"接口测试 正常情况 正常情况正常情况 \" 正常情况 异常情况 异常情况异常情况 \" 异常情况 FastApi 会帮助我们进行类型检测，基本格式校验等 请求体校验 通常，我们在开发的时候，需要用户根据特定的结构体来发起请求，从而防止攻击和过滤用户。 ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:2","tags":["Python","FastApi","后台开发"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["FastApi简明教程"],"content":"FastApi 的数据模型 在 FastApi 中，我们可以借助 pydantic 的 BaseModel 类来实现请求结构体的定义。 ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:3","tags":["Python","FastApi","后台开发"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["FastApi简明教程"],"content":"代码 from pydantic import BaseModel class Mds(BaseModel): name: str age: int home: str @app.post('/models/') async def add_model(model:Mds): return model ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:4","tags":["Python","FastApi","后台开发"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["FastApi简明教程"],"content":"接口测试 正常情况 正常情况正常情况 \" 正常情况 异常情况 异常情况异常情况 \" 异常情况 对于错误的，缺失的结构体字段，FastApi 都会帮我们检测处理。 ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:5","tags":["Python","FastApi","后台开发"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["FastApi简明教程"],"content":"可选字段 FastApi 的可选字段有以下两种场景 字段有默认值时 字段类型为 Optional 时 ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:6","tags":["Python","FastApi","后台开发"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["FastApi简明教程"],"content":"代码 from pydantic import BaseModel from typing import Optional class Mds(BaseModel): name: str age: int = 18 home: str height: Optional[str] @app.post('/models/') async def add_model(model:Mds): return model ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:7","tags":["Python","FastApi","后台开发"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["FastApi简明教程"],"content":"接口测试 只携带必选参数 只携带必选参数只携带必选参数 \" 只携带必选参数 携带全部参数 携带全部参数携带全部参数 \" 携带全部参数 携带多余参数（多余参数会被忽略） 携带多余参数携带多余参数 \" 携带多余参数 缺少必选参数 缺少必选参数缺少必选参数 \" 缺少必选参数 结论 请求结构体的字段，可以多，不可缺少必选的。 请求体使用 我们在视图函数内部可以直接使用请求体的属性。 ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:8","tags":["Python","FastApi","后台开发"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["FastApi简明教程"],"content":"代码 from pydantic import BaseModel from typing import Optional class Mds(BaseModel): name: str age: int = 18 home: str height: Optional[str] @app.post('/models/') async def add_model(Mds:Mds): ret = {} if Mds.name: ret.update({\"Name\":Mds.name}) if Mds.height: ret.update({\"height\":Mds.height}) return ret ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:9","tags":["Python","FastApi","后台开发"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["FastApi简明教程"],"content":"接口测试 接口测试接口测试 \" 接口测试 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-04","objectID":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/:0:10","tags":["Python","FastApi","后台开发"],"title":"FastApi-04-请求体-1","uri":"/fastapi-04-%E8%AF%B7%E6%B1%82%E4%BD%93-1/"},{"categories":["FastApi简明教程"],"content":"何为查询参数 在 FastApi 中，声明不属于路径参数的其他函数参数时，它们将被自动解释为\"查询字符串\"参数。 示例代码 from fastapi import FastAPI import uvicorn app = FastAPI() goods=['xiaomi','apple','huawei','oppo'] @app.get('/goods/') async def get_goods(start:int = 0,end:int = 3): return goods[start:end] if __name__ == \"__main__\": uvicorn.run(app='main:app',host='0.0.0.0',reload=True,debug=True) ","date":"2021-07-03","objectID":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/:0:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-03-查询参数","uri":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"},{"categories":["FastApi简明教程"],"content":"接口测试 带参数 结果结果 \" 结果 带部分参数 因为在后台的视图函数中，两个查询参数都有默认值，所以我们可以对个别参数进行修改后进行请求测试。 结果结果 \" 结果 使用默认参数 当我们在发送请求的时候，不携带查询参数，则后台在接收到请求后会使用默认参数进行处理。即使用start=1，end=3 结果结果 \" 结果 可选参数 在我们实际开发中，某些参数可能需要，也可能不需要，这个根据用户的需求来定。 ","date":"2021-07-03","objectID":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/:0:1","tags":["Python","FastApi","后台开发"],"title":"FastApi-03-查询参数","uri":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"},{"categories":["FastApi简明教程"],"content":"示例代码 @app.get('/name/{name}/age/{age}') async def get_userinfo(name:str,age:int,j:Optional[bool]=False): ret = {'Name':name} if j: ret.update({'Age':age}) return ret 可选参数 j 作为判断条件，默认不返回年龄 age，当 j 为真时就会返回年龄信息。 ","date":"2021-07-03","objectID":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/:0:2","tags":["Python","FastApi","后台开发"],"title":"FastApi-03-查询参数","uri":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"},{"categories":["FastApi简明教程"],"content":"接口测试 普通请求，默认不会返回年龄信息 结果结果 \" 结果 携带参数 j 进行请求，会返回年龄信息 结果结果 \" 结果 参数类型转换 如上，我们在携带参数 j 进行请求的时候其值为 True，FastApi 为我们提供了更为方便的方式，就是查询参数的类型转换，即当其值为任何真值时，都可完成请求处理。 ","date":"2021-07-03","objectID":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/:0:3","tags":["Python","FastApi","后台开发"],"title":"FastApi-03-查询参数","uri":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"},{"categories":["FastApi简明教程"],"content":"示例请求 在 j=1 时进行请求操作 结果结果 \" 结果 在 j=0 时进行请求操作 结果结果 \" 结果 必选的查询参数 在实际开发中，我们可能需要用户必须携带某个参数才能完成请求。 ","date":"2021-07-03","objectID":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/:0:4","tags":["Python","FastApi","后台开发"],"title":"FastApi-03-查询参数","uri":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"},{"categories":["FastApi简明教程"],"content":"代码 我们只需要给上面的代码加上一个参数 q 即可，其余工作 FastApi 都会帮我们完成。 @app.get('/name/{name}/age/{age}') async def get_userinfo(name:str,age:int,q:bool,j:Optional[bool]=False): ret = {'Name':name} if j: ret.update({'Age':age}) return ret ","date":"2021-07-03","objectID":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/:0:5","tags":["Python","FastApi","后台开发"],"title":"FastApi-03-查询参数","uri":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"},{"categories":["FastApi简明教程"],"content":"接口测试 当不带 q 参数进行请求 结果结果 \" 结果 提示查询参数 q 缺失 当带上 q 参数进行请求 结果结果 \" 结果 请求成功 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-03","objectID":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/:0:6","tags":["Python","FastApi","后台开发"],"title":"FastApi-03-查询参数","uri":"/fastapi-03-%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/"},{"categories":["FastApi简明教程"],"content":"何为路径参数 顾名思义，路径参数就是 url 中带的请求参数，比如根据 id 查询信息。 例:自动大写首字母 ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["FastApi简明教程"],"content":"main.py ... @app.get('/format/{name}') async def fmt(name): new_name = name.title() return {'result':new_name} ... ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:1","tags":["Python","FastApi","后台开发"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["FastApi简明教程"],"content":"启动服务后测试 访问：http://127.0.0.1:8765/format/phyger 效果效果 \" 效果 可以看到，功能已经实现！ ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:2","tags":["Python","FastApi","后台开发"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["FastApi简明教程"],"content":"存在的问题 访问：http://127.0.0.1:8765/format/123 效果效果 \" 效果 虽然有结果返回，但是我们期望后台能够对请求参数的格式进行校验。请继续往下看。 默认的路径参数类型都是 str，所以 123 已经被转换成了 str 类型。 带格式的路径参数 当我们在处理数字的时候，我们不希望后台对非法类型的数据进行处理。 ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:3","tags":["Python","FastApi","后台开发"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["FastApi简明教程"],"content":"老代码 ... @app.get('/format1/{num}') async def fmt1(num): print(type(num)) new_num = num+1 return {'result':new_num} ... ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:4","tags":["Python","FastApi","后台开发"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["FastApi简明教程"],"content":"路径参数为 123 的结果 效果效果 \" 效果 Internal Server Error，因为后台将 123 当做 str 处理了，所以在进行计算的时候出错了。 ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:5","tags":["Python","FastApi","后台开发"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["FastApi简明教程"],"content":"新代码 @app.get('/format1/{num}') async def fmt1(num:int): print(type(num)) new_num = num+1 return {'result':new_num} ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:6","tags":["Python","FastApi","后台开发"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["FastApi简明教程"],"content":"路径参数为 123 的结果 结果结果 \" 结果 成功！ 路径参数和查询参数的区别 路径参数是归属 url 的部分，而查询参数是在 url 后面使用?进行连接的参数。通常我们会将某个模块数据结构主键部分使用路径参数表达，而对于这个对象的附加信息我们通常使用查询参数表达。 顾名思义，路径参数指导我们拿到对象概要信息，而查询参数能够帮助我们查询到对象的更多信息。 关于更多查询参数的内容，我们下节内容继续分享。 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-02","objectID":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/:0:7","tags":["Python","FastApi","后台开发"],"title":"FastApi-02-路径参数","uri":"/fastapi-02-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"},{"categories":["FastApi简明教程"],"content":"FastApi是什么 顾名思义，FastApi就是一个用于构建高性能api的web框架。 FastApi的特点 快速：比肩NodeJs和Go 高效：开发效率提升一倍多 少BUG：减少开发错误率 智能：自动补全 简单：易于学习 简短：代码简小精悍 健壮：生产级别可用 文档：自动生成交互式文档 标准化：基于OpenApi FastApi的安装 pip install fastapi[all] FastApi之hello world ","date":"2021-07-01","objectID":"/fastapi-01-%E5%88%9D%E8%AF%86/:0:0","tags":["Python","FastApi","后台开发"],"title":"FastApi-01-初识","uri":"/fastapi-01-%E5%88%9D%E8%AF%86/"},{"categories":["FastApi简明教程"],"content":"main.py from fastapi import FastAPI app = FastAPI() @app.get('/') async def root(): return {'message':'hello world!'} ","date":"2021-07-01","objectID":"/fastapi-01-%E5%88%9D%E8%AF%86/:0:1","tags":["Python","FastApi","后台开发"],"title":"FastApi-01-初识","uri":"/fastapi-01-%E5%88%9D%E8%AF%86/"},{"categories":["FastApi简明教程"],"content":"命令行启动 uvicorn.exe main:app --reload INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) INFO: Started reloader process [18784] using statreload INFO: Started server process [23504] INFO: Waiting for application startup. INFO: Application startup complete. 打开 http://127.0.0.1:8000 查看效果 helloworldhelloworld \" helloworld 可以看到，后台程序已经成功返回。 ","date":"2021-07-01","objectID":"/fastapi-01-%E5%88%9D%E8%AF%86/:0:2","tags":["Python","FastApi","后台开发"],"title":"FastApi-01-初识","uri":"/fastapi-01-%E5%88%9D%E8%AF%86/"},{"categories":["FastApi简明教程"],"content":"主函数启动 from fastapi import FastAPI import uvicorn app = FastAPI() @app.get('/') async def root(): return {'message':'hello world!'} if __name__ == \"__main__\": uvicorn.run(app='main:app',host='127.0.0.1',port=8765,reload=True,debug=True) 启动： python main.py 交互式的API文档 ","date":"2021-07-01","objectID":"/fastapi-01-%E5%88%9D%E8%AF%86/:0:3","tags":["Python","FastApi","后台开发"],"title":"FastApi-01-初识","uri":"/fastapi-01-%E5%88%9D%E8%AF%86/"},{"categories":["FastApi简明教程"],"content":"docs 浏览器访问：127.0.0.1:8765/docs docsdocs \" docs 展开看下接口详细信息 接口详细信息接口详细信息 \" 接口详细信息 点击右侧的Try it Try itTry it \" Try it 即可实现接口调试！ 完美！ ","date":"2021-07-01","objectID":"/fastapi-01-%E5%88%9D%E8%AF%86/:0:4","tags":["Python","FastApi","后台开发"],"title":"FastApi-01-初识","uri":"/fastapi-01-%E5%88%9D%E8%AF%86/"},{"categories":["FastApi简明教程"],"content":"redoc 浏览器访问：127.0.0.1:8765/redoc redocredoc \" redoc FastApi和Flask的区别 经常看到有人把 FastAPI 和 Flask 放到一起比较，但是却没有意识到这完全是两种东西——前者是基于 Web 框架 Starlette 添加了 Web API 功能支持的（框架之上的）框架，而后者是和 Starlette 同类的通用 Web 框架，所以他两本就不是相同的东西，所以还是不要强行比较，选择适合自己的才是正确的。 至于说FastApi使用了asyncio而使得它的性能提升很大，在我看来没有网上介绍的那么夸张。因为在gevent的加持下，其他web框架也可以做到很高的并发，况且一般的服务都是会借助中间件和集群来实现高并发的，所以对于FastApi的高性能大家还是理性看待。感兴趣的同学可以去测试看看实际的结果。 本系列主要是介绍FastApi这个新的web框架，让大家能够对它有所了解，从而合理使用。 至此，FastApi的简单介绍结束。 感谢您的阅读，别忘了关注，点赞，评论，转发四连哟！ ","date":"2021-07-01","objectID":"/fastapi-01-%E5%88%9D%E8%AF%86/:0:5","tags":["Python","FastApi","后台开发"],"title":"FastApi-01-初识","uri":"/fastapi-01-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程"],"content":"什么是 Vue 众所周知，Vue 是前端领域知名的渐进式框架。有了它，我们不用直接操作 DOM，Vue 为我们提供了很多优雅的操作 DOM 的接口。使用 Vue 进行前端工程开发已经成为相当一部分开发者的选择。 如何使用 Vue 和其他框架一样，Vue 也拥有 CDN 在线加速资源，初学，我建议使用在线 CDN 进行学习。 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:0:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程"],"content":"推荐的 Vue 的 CDN 资源 \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e 你只需要将如上代码复制粘贴到 HTML 的 head 部分即可。 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:1:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程"],"content":"Demo-1-模板渲染 此 Demo 实现通过 Vue 对 DOM 进行数据渲染。 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003e{{ messages }}\u003c/h1\u003e \u003c/div\u003e \u003cscript\u003e var app1 = new Vue ( { el: '#app', data: { messages: 'hello Vue!' } } ) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:2:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程"],"content":"页面效果 页面效果\" 页面效果 现在页面的模板对象已经被 Vue 渲染，数据和 DOM 进行了绑定，数据由 Vue 提供，那我们如何确认呢？ 我们可以在控制台对 Vue 对象的数据元素进行修改，查看 DOM 会不会同步变化。 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:2:1","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程"],"content":"执行命令 app1.messages='hello Phyger!' ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:3:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程"],"content":"修改前 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:4:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程"],"content":"修改后 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:5:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程"],"content":"Demo-2-实战 此实战利用数据渲染简单实现点击按钮，显示当前时间的功能。 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:6:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003e{{ messages }}\u003c/h1\u003e \u003cbutton v-on:click='sj'\u003e点我查看当前时间\u003c/button\u003e \u003c/div\u003e \u003cscript\u003e var app1 = new Vue ( { el: '#app', data: { messages: 'hello Vue!' }, methods:{ sj: function(){ this.messages='当前时间：' + new Date().toLocaleTimeString() } } } ) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:6:1","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程"],"content":"页面效果 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:6:2","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程"],"content":"点击按钮后的效果 页面效果\" 页面效果 再点击一次 页面效果\" 页面效果 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:6:3","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程"],"content":"背景 当我们需要操作元素的 class 列表时，我们可以使用 v-bind 实现，但是直接计算整体字符显得很笨，针对这个问题，Vue 做了专门的加强，我们可以通过 v-bind:class 对 class 实现动态绑定。 实践 ","date":"2021-06-15","objectID":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/:0:0","tags":["Vue","前端"],"title":"Vue-10-Class的动态绑定","uri":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"作用于对象(模板内联) 效果：我们可以通过操作 Vue 的 attribute 来实现对 class 的更改。 ","date":"2021-06-15","objectID":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/:1:0","tags":["Vue","前端"],"title":"Vue-10-Class的动态绑定","uri":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e .red {background-color: red} .bb {height: 400px;} .normal {width: 400px;} \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"vpp\" class='normal' v-bind:class=\"{red:isred,bb:isbb}\"\u003e \u003cp\u003emsg\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e app = new Vue({ el: \"#vpp\", data: { isred: true, isbb: false } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/:1:1","tags":["Vue","前端"],"title":"Vue-10-Class的动态绑定","uri":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"页面效果 ","date":"2021-06-15","objectID":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/:1:2","tags":["Vue","前端"],"title":"Vue-10-Class的动态绑定","uri":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"Tip 实际上，class 的动态绑定是通过 Vue data 属性的 truthiness（是否为真）来控制的。如果为真则加载 class，如果为假则不加载。 如上，当 isbb 为 true 时，isbb 对象的 key==\u003ebb 样式才会加载。 默认样式为 div 宽 400px；背景颜色为红色。当我们修改 isbb 属性值后，div 的高度也变为 400px； ","date":"2021-06-15","objectID":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/:1:3","tags":["Vue","前端"],"title":"Vue-10-Class的动态绑定","uri":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"作用于对象(非模板内联) 上面的class是在模板语法内条件使能的，如果你觉得麻烦，也可以选择一下这种更直接的方法，即模板中定义对象的整体，Vue的data中定义对象的具体内容。 ","date":"2021-06-15","objectID":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/:2:0","tags":["Vue","前端"],"title":"Vue-10-Class的动态绑定","uri":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e .red {background-color: red} .bb {height: 400px;} .normal {width: 400px;} \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"vpp\" class='normal' v-bind:class=\"clsObj\"\u003e \u003cp\u003emsg\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e app = new Vue({ el: \"#vpp\", data: { isred: true, isbb: false, clsObj: { red: true, bb: false } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/:2:1","tags":["Vue","前端"],"title":"Vue-10-Class的动态绑定","uri":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"页面效果 和上面的一样 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/:2:2","tags":["Vue","前端"],"title":"Vue-10-Class的动态绑定","uri":"/vue-10-class%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"条件渲染 当我们需要根据不同的条件对前端页面进行不同的渲染时，我们就需要用到条件渲染。Vue 为我们提供了 v-if、v-else-if、v-else 方法。 实践 ","date":"2021-06-15","objectID":"/vue-11-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/:0:0","tags":["Vue","前端"],"title":"Vue-11-条件渲染","uri":"/vue-11-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"},{"categories":["Vue简明教程"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e 请输入成绩等级：\u003cinput v-model=\"type\"\u003e \u003cbr\u003e \u003cp\u003e你输入的内容是：{{ type }}\u003c/p\u003e \u003cdiv v-if=\"type=='C'\"\u003e \u003ch1\u003e及格\u003c/h1\u003e \u003c/div\u003e \u003cdiv v-else-if=\"type=='A'\"\u003e \u003ch1\u003e优秀\u003c/h1\u003e \u003c/div\u003e \u003cdiv v-else\u003e \u003ch1\u003e不及格\u003c/h1\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript\u003e app = new Vue({ el: \"#app\", data: { type: \"C\" } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-11-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/:1:0","tags":["Vue","前端"],"title":"Vue-11-条件渲染","uri":"/vue-11-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"},{"categories":["Vue简明教程"],"content":"页面效果 初始： 输入 A 之后： 输入其他值： Tips v-model 实现了输入框内容和数据的绑定。 v-if 等实现了根据数据的不同值展示不同的内容。 在 v-if 模板中双引号内是单引号。 条件渲染的另一种方式 如上的形式是在页面中直接写上了 v-if 来进行条件判断，这样不是很优雅，我们尝试使用字典，根据不同的 key 来渲染不同的 value 来进行改造。 ","date":"2021-06-15","objectID":"/vue-11-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/:2:0","tags":["Vue","前端"],"title":"Vue-11-条件渲染","uri":"/vue-11-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"},{"categories":["Vue简明教程"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e 请输入成绩等级：\u003cinput v-model=\"type\" placeholder=\"请输入正确的等级！(A,B,C,D)\"\u003e \u003cbr\u003e \u003cp\u003e你输入的内容是：{{ type }}\u003c/p\u003e \u003ch2\u003e{{ res[type] }}\u003c/h2\u003e \u003c/div\u003e \u003cscript\u003e app = new Vue({ el: \"#app\", data: { type: \"C\", res: {\"C\":\"及格\",\"A\":\"优秀\",\"B\":\"优良\",\"D\":\"不及格\"} } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-11-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/:3:0","tags":["Vue","前端"],"title":"Vue-11-条件渲染","uri":"/vue-11-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"},{"categories":["Vue简明教程"],"content":"页面效果 初始： 初始初始 \" 初始 输入 A： 输入A输入A \" 输入A 输入 D： 输入D输入D \" 输入D 我们发现针对可以确定的条件和结果，使用字典的方式，页面代码更优雅。不过，v-if 使用起来也是非常不多呢！ 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-11-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/:4:0","tags":["Vue","前端"],"title":"Vue-11-条件渲染","uri":"/vue-11-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"},{"categories":["Vue简明教程"],"content":"背景 通常在我们的登录页面会有多种登录类型，我们可以通过条件渲染来切换不同的登录表单。 实践 ","date":"2021-06-15","objectID":"/vue-12-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/:0:0","tags":["Vue","前端"],"title":"Vue-12-条件渲染（可重复元素）","uri":"/vue-12-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"categories":["Vue简明教程"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ctemplate v-if=\"loginType=='username'\"\u003e \u003clabel for=\"#user\"\u003eusername: \u003c/label\u003e \u003cinput type=\"text\" id=\"user\"\u003e \u003c/template\u003e \u003ctemplate v-else=\"loginType=='email'\"\u003e \u003clabel for=\"#email\"\u003eemail: \u003c/label\u003e \u003cinput type=\"email\" id=\"email\"\u003e \u003c/template\u003e \u003cbr\u003e\u003cbr\u003e \u003cbutton @click='change'\u003e点我切换登录方式\u003c/button\u003e \u003c/div\u003e \u003cscript\u003e app = new Vue({ el: \"#app\", data: { loginType: \"username\" }, methods: { change: function(){ if(this.loginType==\"username\"){ this.loginType=\"email\"; }else{ this.loginType=\"username\"; } } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-12-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/:0:1","tags":["Vue","前端"],"title":"Vue-12-条件渲染（可重复元素）","uri":"/vue-12-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"categories":["Vue简明教程"],"content":"页面效果 初始： 点击切换登录方式： ","date":"2021-06-15","objectID":"/vue-12-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/:0:2","tags":["Vue","前端"],"title":"Vue-12-条件渲染（可重复元素）","uri":"/vue-12-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"categories":["Vue简明教程"],"content":"存在问题 当我们在 username 登录页面输入了信息后，再切换到 email，你会发现输入框中的内容还在，这是因为两种登录类型使用的输入框是同一个元素。Vue 为我们提供了解决方案，即给输入框加上 key 属性即可。 切换前： 切换后： ","date":"2021-06-15","objectID":"/vue-12-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/:0:3","tags":["Vue","前端"],"title":"Vue-12-条件渲染（可重复元素）","uri":"/vue-12-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"categories":["Vue简明教程"],"content":"优化后的代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ctemplate v-if=\"loginType=='username'\"\u003e \u003clabel for=\"#user\"\u003eusername: \u003c/label\u003e \u003cinput type=\"text\" id=\"user\" key=\"username-input\"\u003e \u003c/template\u003e \u003ctemplate v-else=\"loginType=='email'\"\u003e \u003clabel for=\"#email\"\u003eemail: \u003c/label\u003e \u003cinput type=\"email\" id=\"email\" key=\"email-input\"\u003e \u003c/template\u003e \u003cbr\u003e\u003cbr\u003e \u003cbutton @click='change'\u003e点我切换登录方式\u003c/button\u003e \u003c/div\u003e \u003cscript\u003e app = new Vue({ el: \"#app\", data: { loginType: \"username\" }, methods: { change: function(){ if(this.loginType==\"username\"){ this.loginType=\"email\"; }else{ this.loginType=\"username\"; } } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-12-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/:0:4","tags":["Vue","前端"],"title":"Vue-12-条件渲染（可重复元素）","uri":"/vue-12-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"categories":["Vue简明教程"],"content":"页面效果 切换前： 切换后： 你会发现，加了 key 之后，在切换登录类型后，输入框中的内容已经被清理掉了。 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-12-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/:0:5","tags":["Vue","前端"],"title":"Vue-12-条件渲染（可重复元素）","uri":"/vue-12-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"categories":["Vue简明教程"],"content":"背景 你可能已经知道 Vue 中有两个条件渲染方法，即 v-if 和 v-show，那么对于他两有什么却别和使用场景呢？今天我们就一起来看下。 实践 ","date":"2021-06-15","objectID":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["Vue","前端"],"title":"Vue-13-Vif和Vshow的区别","uri":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"v-if ","date":"2021-06-15","objectID":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/:1:0","tags":["Vue","前端"],"title":"Vue-13-Vif和Vshow的区别","uri":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"特点 真条件渲染（即要什么给什么） 开销大 适合低频操作 节省内存 可以处理 else ","date":"2021-06-15","objectID":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/:1:1","tags":["Vue","前端"],"title":"Vue-13-Vif和Vshow的区别","uri":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e 请输入成绩等级：\u003cinput v-model=\"type\"\u003e \u003cbr\u003e \u003cp\u003e你输入的内容是：{{ type }}\u003c/p\u003e \u003cdiv v-if=\"type=='C'\"\u003e \u003ch1\u003e及格\u003c/h1\u003e \u003c/div\u003e \u003cdiv v-else-if=\"type=='A'\"\u003e \u003ch1\u003e优秀\u003c/h1\u003e \u003c/div\u003e \u003cdiv v-else\u003e \u003ch1\u003e不及格\u003c/h1\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript\u003e app = new Vue({ el: \"#app\", data: { type: \"C\" } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/:1:2","tags":["Vue","前端"],"title":"Vue-13-Vif和Vshow的区别","uri":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"页面效果 初始： 输入 A： ","date":"2021-06-15","objectID":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/:1:3","tags":["Vue","前端"],"title":"Vue-13-Vif和Vshow的区别","uri":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"v-show ","date":"2021-06-15","objectID":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/:2:0","tags":["Vue","前端"],"title":"Vue-13-Vif和Vshow的区别","uri":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"特点 假条件渲染（即一次全部给） 开销小 适合高频操作 费内存 无法处理 else ","date":"2021-06-15","objectID":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/:2:1","tags":["Vue","前端"],"title":"Vue-13-Vif和Vshow的区别","uri":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e 请输入成绩等级：\u003cinput v-model=\"type\"\u003e \u003cbr\u003e \u003cp\u003e你输入的内容是：{{ type }}\u003c/p\u003e \u003cdiv v-show=\"type=='C'\"\u003e \u003ch1\u003e及格\u003c/h1\u003e \u003c/div\u003e \u003cdiv v-show=\"type=='A'\"\u003e \u003ch1\u003e优秀\u003c/h1\u003e \u003c/div\u003e \u003cdiv v-show=\"type=='D'\"\u003e \u003ch1\u003e不及格\u003c/h1\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript\u003e app = new Vue({ el: \"#app\", data: { type: \"C\" } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/:2:2","tags":["Vue","前端"],"title":"Vue-13-Vif和Vshow的区别","uri":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"页面效果 初始： 输入 A： 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/:2:3","tags":["Vue","前端"],"title":"Vue-13-Vif和Vshow的区别","uri":"/vue-13-vif%E5%92%8Cvshow%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"前言 在前面的章节中，我们已经了解了关于 Vue 的条件渲染，今天我们就一起来看看 Vue 的列表渲染，即 For 循环。 例子 ","date":"2021-06-15","objectID":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/:0:0","tags":["Vue","前端"],"title":"Vue-14-列表渲染v-for","uri":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/"},{"categories":["Vue简明教程"],"content":"v-for 和 Python 中的 for 循环一样，Vue 的列表渲染也遵循 item in items 的规范。item 为 items 中的元素别名。 ","date":"2021-06-15","objectID":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/:0:1","tags":["Vue","前端"],"title":"Vue-14-列表渲染v-for","uri":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/"},{"categories":["Vue简明教程"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003eVfor\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003col id=\"app\"\u003e \u003cli v-for=\"item in items\" :key=\"item.title\"\u003e {{ item.title }} \u003c/li\u003e \u003c/ol\u003e \u003cscript\u003e app = new Vue({ el: '#app', data:{ \"items\":[ {title: 'phyger'}, {title: 'fly'} ] } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/:0:2","tags":["Vue","前端"],"title":"Vue-14-列表渲染v-for","uri":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/"},{"categories":["Vue简明教程"],"content":"效果 ","date":"2021-06-15","objectID":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/:0:3","tags":["Vue","前端"],"title":"Vue-14-列表渲染v-for","uri":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/"},{"categories":["Vue简明教程"],"content":"v-for 中使用对象 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003eVfor\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003col\u003e \u003cli v-for=\"item in items\" :key=\"item.title\"\u003e {{ item.title }} \u003c/li\u003e \u003c/ol\u003e \u003ch1\u003eAuthors Info\u003c/h1\u003e \u003cul\u003e \u003cli v-for=\"value,key,index in objs\"\u003e {{ index }} : {{ key }} : {{ value }} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e app = new Vue({ el: '#app', data:{ \"items\":[ {title: 'phyger'}, {title: 'fly'} ], \"objs\": { name: \"phyger\", home: \"xian\", age: 18 } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 在对对象进行循环遍历的时候，value，key，indx 的顺序是固定的，即第一个参数获对象的值，最后一个参数获取索引。 ","date":"2021-06-15","objectID":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/:0:4","tags":["Vue","前端"],"title":"Vue-14-列表渲染v-for","uri":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/"},{"categories":["Vue简明教程"],"content":"效果 ","date":"2021-06-15","objectID":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/:0:5","tags":["Vue","前端"],"title":"Vue-14-列表渲染v-for","uri":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/"},{"categories":["Vue简明教程"],"content":"v-for 中使用 v-if 假如我们要遍历一个任务列表，但是只显示已完成的任务，此时我们就可以使用 v-for+v-if 实现。 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003eVfor\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003col\u003e \u003cli v-for=\"item in items\" :key=\"item.title\"\u003e {{ item.title }} \u003c/li\u003e \u003c/ol\u003e \u003ch1\u003eAuthors Info\u003c/h1\u003e \u003cul\u003e \u003cli v-for=\"value,key,index in objs\"\u003e {{ index }} : {{ key }} : {{ value }} \u003c/li\u003e \u003c/ul\u003e \u003ch1\u003ev-if in v-for\u003c/h1\u003e \u003col\u003e \u003cli v-for=\"todo in todos\" v-if=\"todo.status==1\"\u003e {{ todo.name }} \u003c/li\u003e \u003c/ol\u003e \u003c/div\u003e \u003cscript\u003e app = new Vue({ el: '#app', data:{ \"items\":[ {title: 'phyger'}, {title: 'fly'} ], \"objs\": { age: 18, name: \"phyger\", home: \"xian\" }, todos: [ {name: 'eat',status: 1}, {name: 'work',status: 1}, {name: 'sleep',status: 0} ] } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e v-if in v-for 场景中，v-for 的优先级要高于 v-if，所以 v-if 会分别在每个 for 循环中重复运行。 ","date":"2021-06-15","objectID":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/:0:6","tags":["Vue","前端"],"title":"Vue-14-列表渲染v-for","uri":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/"},{"categories":["Vue简明教程"],"content":"效果 只显示 status=1 的任务。 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/:0:7","tags":["Vue","前端"],"title":"Vue-14-列表渲染v-for","uri":"/vue-14-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93v-for/"},{"categories":["Vue简明教程"],"content":"前言 前面我们已经了解了条件渲染和列表渲染，计算属性动态绑定等。今天我们学习一个常用的概念：事件绑定，即在事件被触发时执行某些动作。 事件监听 ","date":"2021-06-15","objectID":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/:0:0","tags":["Vue","前端"],"title":"Vue-15-事件绑定","uri":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003evon\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003ev-on中直接执行代码进行计算\u003c/h1\u003e \u003cbutton v-on:click=\"counter += 1\"\u003e点一下\u003c/button\u003e \u003cp\u003e你点击了 {{counter}} 下！\u003c/p\u003e \u003ch1\u003ev-on中调用方法showinfo\u003c/h1\u003e \u003cbutton type=\"button\" @click=\"showinfo\"\u003e点击查看提示\u003c/button\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e // // 江城子 . 程序员之歌 // // 十年生死两茫茫，写程序，到天亮。 // 千行代码，Bug何处藏。 // 纵使上线又怎样，朝令改，夕断肠。 // // 领导每天新想法，天天改，日日忙。 // 相顾无言，惟有泪千行。 // 每晚灯火阑珊处，夜难寐，加班狂。 // app = new Vue({ el: '#app', data: { counter: 0, name: \"phyger\" }, methods:{ showinfo: function(event){ alert('Hello '+this.name+' !'); console.log(event); } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/:0:1","tags":["Vue","前端"],"title":"Vue-15-事件绑定","uri":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"效果 v-on 监听 click 事件，当发生鼠标点击事件时 Vue 会进行 counter 加 1 的动作。 v-on 监听 click 事件，当发生鼠标点击事件时调用 showinfo 方法。 事件参数传递\u0026修饰 ","date":"2021-06-15","objectID":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/:0:2","tags":["Vue","前端"],"title":"Vue-15-事件绑定","uri":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"代码:参数传递 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003evon\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003ev-on中直接执行代码进行计算\u003c/h1\u003e \u003cbutton v-on:click=\"counter += 1\"\u003e点一下\u003c/button\u003e \u003cp\u003e你点击了 {{counter}} 下！\u003c/p\u003e \u003ch1\u003ev-on中调用方法showinfo\u003c/h1\u003e \u003cbutton type=\"button\" @click=\"showinfo\"\u003e点击查看提示\u003c/button\u003e \u003ch1\u003esay something\u003c/h1\u003e \u003cbutton type=\"button\" @click=\"say('good')\"\u003esay good\u003c/button\u003e \u003cbutton type=\"button\" @click=\"say('bad')\"\u003esay bad\u003c/button\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e // // 江城子 . 程序员之歌 // // 十年生死两茫茫，写程序，到天亮。 // 千行代码，Bug何处藏。 // 纵使上线又怎样，朝令改，夕断肠。 // // 领导每天新想法，天天改，日日忙。 // 相顾无言，惟有泪千行。 // 每晚灯火阑珊处，夜难寐，加班狂。 // app = new Vue({ el: '#app', data: { counter: 0, name: \"phyger\" }, methods:{ showinfo: function(event){ alert('Hello '+this.name+' !'); console.log(event); }, say: function(sm,event){ console.log('say '+ sm); } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/:0:3","tags":["Vue","前端"],"title":"Vue-15-事件绑定","uri":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"效果 分别点击 say good 和 say bad 将会传递不同的参数到方法 say 中，从而实现不同的效果。 ","date":"2021-06-15","objectID":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/:0:4","tags":["Vue","前端"],"title":"Vue-15-事件绑定","uri":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"代码：修饰符 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003evon\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003ev-on中直接执行代码进行计算\u003c/h1\u003e \u003cbutton v-on:click=\"counter += 1\"\u003e点一下\u003c/button\u003e \u003cp\u003e你点击了 {{counter}} 下！\u003c/p\u003e \u003ch1\u003ev-on中调用方法showinfo\u003c/h1\u003e \u003cbutton type=\"button\" @click=\"showinfo\"\u003e点击查看提示\u003c/button\u003e \u003ch1\u003esay something\u003c/h1\u003e \u003cbutton type=\"button\" @click.once=\"say('good')\"\u003esay good\u003c/button\u003e \u003cbutton type=\"button\" @click=\"say('bad')\"\u003esay bad\u003c/button\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e // // 江城子 . 程序员之歌 // // 十年生死两茫茫，写程序，到天亮。 // 千行代码，Bug何处藏。 // 纵使上线又怎样，朝令改，夕断肠。 // // 领导每天新想法，天天改，日日忙。 // 相顾无言，惟有泪千行。 // 每晚灯火阑珊处，夜难寐，加班狂。 // app = new Vue({ el: '#app', data: { counter: 0, name: \"phyger\" }, methods:{ showinfo: function(event){ alert('Hello '+this.name+' !'); console.log(event); }, say: function(sm,event){ console.log('say '+ sm); } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 如上，我们为 say good 的按钮的 click 事件添加了 once 的修饰符，意为这个事件仅会触发一次 say 方法。 ","date":"2021-06-15","objectID":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/:0:5","tags":["Vue","前端"],"title":"Vue-15-事件绑定","uri":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"效果 当我们第二次点击 say good 按钮时，say 方法已经不会被触发了，而 say bad 按钮则可以多次触发 say 方法。 ","date":"2021-06-15","objectID":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/:0:6","tags":["Vue","前端"],"title":"Vue-15-事件绑定","uri":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"常用的事件修饰符 stop prevent capture self once passive ","date":"2021-06-15","objectID":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/:0:7","tags":["Vue","前端"],"title":"Vue-15-事件绑定","uri":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"常用的按键修饰符 鼠标： left right middle 键盘： ctrl alt shift meta ","date":"2021-06-15","objectID":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/:0:8","tags":["Vue","前端"],"title":"Vue-15-事件绑定","uri":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"按键修饰符 v-on 监听键盘事件，当发生对应事件触发某些操作。 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003evon\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003ev-on中直接执行代码进行计算\u003c/h1\u003e \u003cbutton v-on:click=\"counter += 1\"\u003e点一下\u003c/button\u003e \u003cp\u003e你点击了 {{counter}} 下！\u003c/p\u003e \u003ch1\u003ev-on中调用方法showinfo\u003c/h1\u003e \u003cbutton type=\"button\" @click=\"showinfo\"\u003e点击查看提示\u003c/button\u003e \u003ch1\u003esay something\u003c/h1\u003e \u003cbutton type=\"button\" @click.once=\"say('good')\"\u003esay good\u003c/button\u003e \u003cbutton type=\"button\" @click=\"say('bad')\"\u003esay bad\u003c/button\u003e \u003ch1\u003epush mouse middle\u003c/h1\u003e \u003cbutton type=\"button\" @click.middle=\"f1\"\u003emouse middle active alert\u003c/button\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e // // 江城子 . 程序员之歌 // // 十年生死两茫茫，写程序，到天亮。 // 千行代码，Bug何处藏。 // 纵使上线又怎样，朝令改，夕断肠。 // // 领导每天新想法，天天改，日日忙。 // 相顾无言，惟有泪千行。 // 每晚灯火阑珊处，夜难寐，加班狂。 // app = new Vue({ el: '#app', data: { counter: 0, name: \"phyger\" }, methods:{ showinfo: function(event){ alert('Hello '+this.name+' !'); console.log(event); }, say: function(sm,event){ console.log('say '+ sm); }, f1: function(){ alert(\"U clicked mouse middle!\") } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/:0:9","tags":["Vue","前端"],"title":"Vue-15-事件绑定","uri":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"效果 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/:0:10","tags":["Vue","前端"],"title":"Vue-15-事件绑定","uri":"/vue-15-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":" 方便演示，代码中只贴了 body 内容。 前言 我们知道 v-model 是双向数据绑定的代表。今天我们就一起来深入了解 v-model 表单绑定的更多内容。 使用场景 我们可以使使用 v-model 监听 input，textarea，select 元素上创建双向数据绑定，也可以根据 checkbox 和 radio 的 checked 和 change 事件来实现数据绑定，具体如下： 1、text 和 textarea 元素使用 value property 和 input 事件； 2、checkbox 和 radio 使用 checked property 和 change 事件； 3、select 字段将 value 作为 prop 并将 change 作为事件。 实例 ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:0:0","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"文本绑定 \u003cbody\u003e \u003cdiv id=\"appv\"\u003e 请输入内容: \u003cinput v-model=\"info\"\u003e \u003cp\u003e你输入的内容是：{{ info }}\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e app = new Vue({ el: \"#appv\", data: { info: \"placeholder\", } }) \u003c/script\u003e \u003c/body\u003e ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:1:0","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"多行文本绑定 \u003cbody\u003e \u003cdiv id=\"appv\"\u003e 请输入内容:\u003cbr\u003e\u003cbr\u003e \u003ctextarea rows=\"\" cols=\"\" v-model=\"info\"\u003e\u003c/textarea\u003e \u003cp style=\"white-space: pre-line;\"\u003e你输入的内容是：\u003cbr\u003e\u003cbr\u003e{{ info }}\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e app = new Vue({ el: \"#appv\", data: { info: \"placeholder\", } }) \u003c/script\u003e \u003c/body\u003e ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:2:0","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"复选框 v-model 可以智能的将 v-model 的值绑定到 checked 属性中，从而实现选定与取消选定。 ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:3:0","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"单个复选框，绑定到布尔值 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003clabel for=\"ck\"\u003e{{ ckb }}\u003c/label\u003e \u003cinput id=\"ck\" type=\"checkbox\" v-model=\"ckb\"\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e app = new Vue({ el: \"#app\", data: { ckb: true } }) \u003c/script\u003e \u003c/body\u003e ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:3:1","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"多个复选框，绑定到同一数组 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003clabel for=\"ck\"\u003e{{ ckb }}\u003c/label\u003e \u003cinput id=\"ck\" type=\"checkbox\" v-model=\"ckb\"\u003e \u003cdiv class=\"mui-input-row mui-checkbox \"\u003e \u003clabel for=\"c1\"\u003eP1\u003c/label\u003e \u003cinput id=\"c1\" type=\"checkbox\" v-model=\"persons\" value=\"中国人\"\u003e \u003clabel for=\"c2\"\u003eP2\u003c/label\u003e \u003cinput id=\"c2\" type=\"checkbox\" v-model=\"persons\" value=\"德国人\"\u003e \u003clabel for=\"c3\"\u003eP3\u003c/label\u003e \u003cinput id=\"c3\" type=\"checkbox\" v-model=\"persons\" value=\"俄罗斯人\"\u003e \u003cp\u003e您的选择的是:{{ persons }}\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e app = new Vue({ el: \"#app\", data: { ckb: true, persons: [] } }) \u003c/script\u003e \u003c/body\u003e 多个复选框使用用一个 v-model，此时复选框被选中时，复选框的 value 会被自动添加到 v-model 绑定的数组中去。 ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:3:2","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"单选框 当单选框的选择发生变化的时候，v-model 绑定的值会自动切换为当前选择的单选框的 value 值。 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cdiv class=\"mui-input-row mui-radio \"\u003e \u003clabel for=\"r1\"\u003e中国\u003c/label\u003e \u003cinput id=\"r1\" type=\"radio\" v-model=\"info\" value=\"伟大的国家！\" checked\u003e \u003cbr\u003e \u003clabel for=\"r2\"\u003e日本\u003c/label\u003e \u003cinput id=\"r2\" type=\"radio\" v-model=\"info\" value=\"二战战败国！\"\u003e \u003cbr\u003e \u003cp\u003e对应国家的描述：{{ info }}\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e app =new Vue({ el: \"#app\", data: { info: \"\" } }) \u003c/script\u003e \u003c/body\u003e ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:4:0","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"下拉选框 v-model 绑定的值会根据下拉选框选择的值自动发生变化。 ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:5:0","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"单选时 v-model 绑定的是字符串 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cselect name=\"ABC\" v-model=\"select\"\u003e \u003coption disabled=\"\" value=\"\"\u003e请选择\u003c/option\u003e \u003coption value =\"A-value\"\u003eA\u003c/option\u003e \u003coption value =\"B-value\"\u003eB\u003c/option\u003e \u003coption value =\"C-value\"\u003eC\u003c/option\u003e \u003c/select\u003e \u003cp\u003e您选择的选项的value是：{{ select }}\u003c/p\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e app = new Vue({ el: \"#app\", data: { select: \"\" } }) \u003c/script\u003e \u003c/body\u003e ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:5:1","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"多选时 v-model 绑定的是数组 即使 v-model 绑定的元数据类型是字符，也会被 Vue 强制转换为数组。 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cselect name=\"ABC\" v-model=\"select\" multiple=\"multiple\"\u003e \u003coption value =\"A-value\"\u003eA\u003c/option\u003e \u003coption value =\"B-value\"\u003eB\u003c/option\u003e \u003coption value =\"C-value\"\u003eC\u003c/option\u003e \u003c/select\u003e \u003cp\u003e您选择的选项的value是：{{ select }}\u003c/p\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e app = new Vue({ el: \"#app\", data: { select: \"\" } }) \u003c/script\u003e \u003c/body\u003e ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:5:2","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"动态渲染（循环）@下拉框的值绑定 对于列表选项很多，且需要动态调整的拉下选框，我们可以使用 v-for 加 v-bind 对选项的内容进行循环展示。 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cselect v-model=\"kvs\"\u003e \u003coption v-for=\" item in items\" v-bind:value=\"item.v\"\u003e{{ item.k }}\u003c/option\u003e \u003c/select\u003e \u003cp\u003e您选择的选项的value是：{{ kvs }}\u003c/p\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e app = new Vue({ el: \"#app\", data: { kvs: '\u003c待选择\u003e', items: [ {k:\"中国\",v:\"伟大的国家\"}, {k:\"美国\",v:\"强大的国家\"}, {k:\"日本\",v:\"猥琐的国家\"} ] } }) \u003c/script\u003e \u003c/body\u003e ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:5:3","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"值绑定 通常，对于选中的复选框，v-model 绑定的值是布尔。单选框和下拉选框选中时，v-model 取的是 value 的值。 如果我们想要自定义选中时的值，我们就需要使用 v-bind 等方式来绑定值。 ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:6:0","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"复选框的值绑定 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cdiv class=\"mui-input-row mui-checkbox mui-left\"\u003e \u003clabel for=\"checkbox1\" \u003e{{ c1 }}\u003c/label\u003e \u003cinput id=\"checkbox1\" type=\"checkbox\" v-model=\"c1\" true-value='选中了' false-value='没选中' checked\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e app = new Vue({ el: \"#app\", data: { c1: \"选中了\" } }) \u003c/script\u003e \u003c/body\u003e ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:6:1","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"单选框的值绑定 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cdiv class=\"mui-input-row mui-checkbox mui-left\"\u003e \u003clabel for=\"checkbox1\" \u003e{{ c1 }}\u003c/label\u003e \u003cinput id=\"checkbox1\" type=\"checkbox\" v-model=\"c1\" true-value='选中了' false-value='没选中' checked\u003e \u003c/div\u003e \u003cbr\u003e \u003cdiv class=\"mui-input-row mui-radio \"\u003e \u003clabel for=\"r1\"\u003eA\u003c/label\u003e \u003cinput id=\"r1\" type=\"radio\" checked v-model=\"RR\" v-bind:value=\"vv.a\"\u003e \u003clabel for=\"r2\"\u003eB\u003c/label\u003e \u003cinput id=\"r2\" type=\"radio\" v-model=\"RR\" v-bind:value=\"vv.b\"\u003e \u003clabel for=\"r3\"\u003eC\u003c/label\u003e \u003cinput id=\"r3\" type=\"radio\" v-model=\"RR\" v-bind:value=\"vv.c\"\u003e \u003cbr\u003e 你选了：{{ RR }} ！ \u003c/div\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e app = new Vue({ el: \"#app\", data: { c1: \"选中了\", RR: \"选中了A\", // RR为选中了A时，Vue会自动将radio checked，RR值为null时，Vue会自动将radio unchecked vv: { a: \"选中了A\", b: \"选中了B\", c: \"选中了C\" } } }) \u003c/script\u003e \u003c/body\u003e ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:6:2","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"修饰符 ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:7:0","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":".lazy 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步，如果你想要在 change 事件后再同步，那么你可能需要使用 lazy 修饰符。 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cinput type=\"text\" v-model=\"msg\" placeholder=\"请输入\"/\u003e \u003cbr\u003e \u003cspan\u003e 你最终输入的是：{{ msg }} \u003c/span\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e app = new Vue({ el: \"#app\", data: { msg: \"\" } }) \u003c/script\u003e \u003c/body\u003e ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:7:1","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":".number 如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符。 \u003cinput v-model.number=\"age\" type=\"number\"\u003e 这通常很有用，因为即使在 type=\"number\" 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 parseFloat() 解析，则会返回原始的值。 ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:7:2","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":".trim 如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符。 \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cinput type=\"text\" v-model.lazy.trim=\"msg\" placeholder=\"请输入\"/\u003e \u003cbr\u003e \u003cspan\u003e 你最终输入的是：前{{ msg }}后 \u003c/span\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e app = new Vue({ el: \"#app\", data: { msg: \"\" } }) \u003c/script\u003e \u003c/body\u003e 你会发现文本前后的空格都被过滤掉了，但是文本中间的空格不会被过滤。 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/:7:3","tags":["Vue","前端"],"title":"Vue-16-表单绑定","uri":"/vue-16-%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程"],"content":"什么是组件？ 官方文档说，组件是带有名称的可复用实例。实际上你可以理解组件就是一个名为 zj 的 html 模板，当你要使用这个 html 模板的时候，你可以直接用 zj 标签即可。 组件初识 鉴于 Vue3 的逐步推广，所以从本篇文章开始，我们直接切换 Vue3 进行学习。 ","date":"2021-06-15","objectID":"/vue-17-%E7%BB%84%E4%BB%B6/:0:0","tags":["Vue","前端"],"title":"Vue-17-组件","uri":"/vue-17-%E7%BB%84%E4%BB%B6/"},{"categories":["Vue简明教程"],"content":"简单的例子 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003ecomponent\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@next\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cdemo\u003e\u003c/demo\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e // 创建一个Vue 应用 const Vapp = Vue.createApp({}) // 定义一个名为 demo的新全局组件 // 在demo组件中嵌入全局组件demo1 Vapp.component('demo', { template: '\u003cdiv\u003e\u003ch1\u003e我的自定义组件!\u003c/h1\u003e\u003cbr\u003e\u003cdemo1\u003e\u003c/demo1\u003e\u003c/div\u003e', }) // 定义一个名为demo1的全局组件 Vapp.component('demo1', { template: '\u003cdiv\u003e\u003ch2\u003e我的demo1组件!\u003c/h2\u003e\u003cbr\u003e\u003c/div\u003e', }) // 将Vue的app挂载到app元素上 Vapp.mount('#app') \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 虽然我们只在 body 中使用 demo 组件，但是 demo 组件又内嵌了 demo1 组件，所以 demo1 的内容也会被展示。你大概可以感受到模块化的好处。 ","date":"2021-06-15","objectID":"/vue-17-%E7%BB%84%E4%BB%B6/:1:0","tags":["Vue","前端"],"title":"Vue-17-组件","uri":"/vue-17-%E7%BB%84%E4%BB%B6/"},{"categories":["Vue简明教程"],"content":"优点 由于组件可以复用的特点，当我们的组件被引用多次的时候，如果组件的内容发生变化，那我们直接修改源组件即可，引用它的地方都会自动刷新。 假设需要将 demo1 内容显示为红色，那么我们可以这样做： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003ecomponent\u003c/title\u003e \u003cscript src=\"https://unpkg.com/vue@next\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e 第一次引用 \u003cdemo\u003e\u003c/demo\u003e \u003chr \u003e 第二次引用 \u003cdemo\u003e\u003c/demo\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e // 创建一个Vue 应用 const Vapp = Vue.createApp({}) // 定义一个名为 demo的新全局组件 // 在demo组件中嵌入全局组件demo1 Vapp.component('demo', { template: '\u003cdiv\u003e\u003ch1\u003e我的自定义组件!\u003c/h1\u003e\u003cbr\u003e\u003cdemo1\u003e\u003c/demo1\u003e\u003c/div\u003e', }) // 定义一个名为demo1的全局组件 Vapp.component('demo1', { template: '\u003cdiv class=\"rd\"\u003e\u003ch2\u003e我的demo1组件!\u003c/h2\u003e\u003cbr\u003e\u003c/div\u003e', }) // 将Vue的app挂载到app元素上 Vapp.mount('#app') \u003c/script\u003e \u003cstyle type=\"text/css\"\u003e .rd { color: #FF0000; } \u003c/style\u003e \u003c/body\u003e \u003c/html\u003e 如上，组件 demo1 被引用了两次，当我们需要修改 demo1 的样式时，我们不需要你修改两次，只需要修改 demo1 组件的样式即可。 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-17-%E7%BB%84%E4%BB%B6/:2:0","tags":["Vue","前端"],"title":"Vue-17-组件","uri":"/vue-17-%E7%BB%84%E4%BB%B6/"},{"categories":["Vue简明教程"],"content":"指令 Vue 中，有很多常用的指令，你可以理解它是可以绑定在指定的 action 上的。 实例 ","date":"2021-06-15","objectID":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:0:0","tags":["Vue","前端"],"title":"Vue-2-常用指令","uri":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Vue简明教程"],"content":"v-bind v-bind 就是 Vue 中一个常见的指令，其中 v- 前缀代表这是 Vue 为我们提供的指令，下面的例子将实现鼠标悬停在被绑定的元素上后显示它的 title 信息。 ","date":"2021-06-15","objectID":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:1:0","tags":["Vue","前端"],"title":"Vue-2-常用指令","uri":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Vue简明教程"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"vb\"\u003e \u003cspan v-bind:title=\"info\"\u003e悬停显示\u003c/span\u003e \u003c/div\u003e \u003cscript\u003e var app2 = new Vue ({ el: '#vb', data: { info: '此页面加载于：' + new Date().toLocaleString() } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:1:1","tags":["Vue","前端"],"title":"Vue-2-常用指令","uri":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Vue简明教程"],"content":"页面效果 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:1:2","tags":["Vue","前端"],"title":"Vue-2-常用指令","uri":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Vue简明教程"],"content":"v-if 此指令可以实现条件判断，以下实例可以实现当点击按钮时，通过判断绑定元素的 judge 属性，进行元素的显示和隐藏。 ","date":"2021-06-15","objectID":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:2:0","tags":["Vue","前端"],"title":"Vue-2-常用指令","uri":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Vue简明教程"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"vif\"\u003e \u003cbutton v-on:click=\"func1\"\u003e点我\u003c/button\u003e \u003cp v-if=\"judge\"\u003e当点击上面的按钮时我会隐藏！\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e var app4 = new Vue({ el:'#vif', data:{ judge:true }, methods:{ func1:function(){ if(this.judge == true){ this.judge=false; }else{ this.judge=true;} } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 以上代码中，v-on 是用来监听元素的事件，当事件发生的时候会触发对应的方法。 ","date":"2021-06-15","objectID":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:2:1","tags":["Vue","前端"],"title":"Vue-2-常用指令","uri":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Vue简明教程"],"content":"页面效果 页面效果\" 页面效果 点击按钮 页面效果\" 页面效果 再次点击 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:2:2","tags":["Vue","前端"],"title":"Vue-2-常用指令","uri":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Vue简明教程"],"content":"v-for v-for 可以实现对元素的 for 循环，以下实例可以实现页面元素的循环渲染，Vue 提供可遍历数据。 ","date":"2021-06-15","objectID":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:3:0","tags":["Vue","前端"],"title":"Vue-2-常用指令","uri":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Vue简明教程"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"floop\"\u003e \u003col\u003e \u003cli v-for=\"i in is\"\u003e {{ i }} \u003c/li\u003e \u003c/ol\u003e \u003c/div\u003e \u003cscript\u003e var app3 = new Vue({ el: '#floop', data:{ is:[ '西安', '北京', '上海' ] } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:3:1","tags":["Vue","前端"],"title":"Vue-2-常用指令","uri":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Vue简明教程"],"content":"页面效果 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:3:2","tags":["Vue","前端"],"title":"Vue-2-常用指令","uri":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Vue简明教程"],"content":"v-for 进阶 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"floop\"\u003e \u003cul\u003e \u003cli v-for=\"i in is\"\u003e {{ i.name }}: {{ i.goods }} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e var app3 = new Vue({ el: '#floop', data:{ is:[ {'name': '西安','goods': '面食'}, {'name': '北京','goods': '肉食'}, {'name': '上海','goods': '菜食'} ] } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:3:3","tags":["Vue","前端"],"title":"Vue-2-常用指令","uri":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Vue简明教程"],"content":"页面效果 页面效果\" 页面效果 Tip: 如上，Vue 的 Observer 帮我们将普通的 DOM 对象转换成了响应式对象。 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:3:4","tags":["Vue","前端"],"title":"Vue-2-常用指令","uri":"/vue-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Vue简明教程"],"content":"生命周期钩子 和传统的对象一样，Vue 的实例对象也有完整的生命周期过程，在这个过程中 Vue 为我们提供了不用阶段的钩子，机生命周期函数。如果你在实例中声明了这些方法，它们会在对应的阶段自动触发。 生命周期流程图 生命周期流程图\" 生命周期流程图 上图摘自：cn.vuejs.org 演示 我们通过以下代码来对 Vue 实例对象的生命周期进行详细的展示。 ","date":"2021-06-15","objectID":"/vue-3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/:0:0","tags":["Vue","前端"],"title":"Vue-3-生命周期管理","uri":"/vue-3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"},{"categories":["Vue简明教程"],"content":"生命周期阶段 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed ","date":"2021-06-15","objectID":"/vue-3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/:0:1","tags":["Vue","前端"],"title":"Vue-3-生命周期管理","uri":"/vue-3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"},{"categories":["Vue简明教程"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"vif\"\u003e \u003cbutton v-on:click=\"func1\"\u003e点我\u003c/button\u003e \u003cp\u003e{{ judge }}\u003c/p\u003e \u003cp v-if=\"judge\"\u003e当点击上面的按钮时我会隐藏！\u003c/p\u003e \u003cbutton v-on:click=\"func2\"\u003e点击跳转销毁Vue对象\u003c/button\u003e \u003c/div\u003e \u003cscript\u003e var judge=true var app4 = new Vue({ el:'#vif', data:{ judge:judge }, methods:{ func1:function(){ if(this.judge == true){ this.judge=false; }else{ this.judge=true;} }, func2:function(){ this.$destroy(); } }, beforeCreate:function(){ console.log('Vue instance ready2Create...') }, created:function(){ console.log('Vue instance created...') }, beforeUpdate:function(){ console.log('Vue instance beforeUpdate...') }, updated:function(){ console.log('Vue instance updated...') }, beforeMount:function(){ console.log('Vue instance beforeMounte...') }, mounted:function(){ console.log('Vue instance mounted...') }, beforeDestroy:function(){ console.log('Vue instance beforeDestroy...') }, destroyed:function(){ console.log('Vue instance destroyed...') } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/:0:2","tags":["Vue","前端"],"title":"Vue-3-生命周期管理","uri":"/vue-3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"},{"categories":["Vue简明教程"],"content":"页面效果 页面效果\" 页面效果 如上，当我们打开页面的时候，Vue 已经完成了 4 个阶段。 ","date":"2021-06-15","objectID":"/vue-3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/:0:3","tags":["Vue","前端"],"title":"Vue-3-生命周期管理","uri":"/vue-3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"},{"categories":["Vue简明教程"],"content":"触发 update 点击点我，查看控制台日志 控制台日志\" 控制台日志 ","date":"2021-06-15","objectID":"/vue-3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/:0:4","tags":["Vue","前端"],"title":"Vue-3-生命周期管理","uri":"/vue-3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"},{"categories":["Vue简明教程"],"content":"触发 destroy 点击点击跳转销毁Vue对象，查看控制台日志 控制台日志\" 控制台日志 怎么样，Vue 实例的声明周期你学废了吗？ 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/:0:5","tags":["Vue","前端"],"title":"Vue-3-生命周期管理","uri":"/vue-3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"},{"categories":["Vue简明教程"],"content":"什么是模板语法 前面我们已经了解过 HTML 的模板语法，即插值表达式，双大括号的形式。 渲染 ","date":"2021-06-15","objectID":"/vue-4-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-1/:0:0","tags":["Vue","前端"],"title":"Vue-4-模板语法-1","uri":"/vue-4-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-1/"},{"categories":["Vue简明教程"],"content":"文本渲染-响应式 \u003cp\u003e{{ judge }}\u003c/p\u003e 以上代码中的模板，当 judge 的值发生变化时，模板中的值也会自动刷新，因为 judge 属性在 Vue 中是一个响应式对象。 ","date":"2021-06-15","objectID":"/vue-4-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-1/:0:1","tags":["Vue","前端"],"title":"Vue-4-模板语法-1","uri":"/vue-4-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-1/"},{"categories":["Vue简明教程"],"content":"文本渲染-单次 指令：v-once \u003cp v-once\u003e{{ judge }}\u003c/p\u003e 以上代码中的，v-once 可以实现一次性的渲染，当数据改变时，插值处的内容不会更新。同时这个节点内的其他数据也不会更新。 ","date":"2021-06-15","objectID":"/vue-4-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-1/:0:2","tags":["Vue","前端"],"title":"Vue-4-模板语法-1","uri":"/vue-4-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-1/"},{"categories":["Vue简明教程"],"content":"单次渲染演示 代码： \u003cdiv id=\"vif\"\u003e \u003cbutton v-on:click=\"func1\"\u003e点我\u003c/button\u003e \u003cp v-once\u003e{{ judge }}\u003c/p\u003e \u003cp v-if=\"judge\"\u003e当点击上面的按钮时我会隐藏！\u003c/p\u003e \u003cbutton v-on:click=\"func2\"\u003e点击跳转销毁Vue对象\u003c/button\u003e \u003c/div\u003e 页面效果: 页面效果\" 页面效果 点击点我，没有 v-once 标记时，true 会变为 false，而 v-once 标记后，true 则不会变化。 页面效果\" 页面效果 如上，数据已经隐藏，但是 true 未发生变化。 ","date":"2021-06-15","objectID":"/vue-4-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-1/:0:3","tags":["Vue","前端"],"title":"Vue-4-模板语法-1","uri":"/vue-4-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-1/"},{"categories":["Vue简明教程"],"content":"HTML 渲染 指令：v-html 代码： \u003cdiv id=\"app\"\u003e \u003ch1\u003e{{ messages }}\u003c/h1\u003e \u003cbutton v-on:click='sj'\u003e点我查看当前时间\u003c/button\u003e \u003c/div\u003e HTML 格式的语言按照如上代码渲染时，默认不会处理 HTML 语言，效果如下： 页面效果\" 页面效果 修改后的代码： \u003cdiv id=\"app\"\u003e \u003ch1\u003e\u003cspan v-html=\"messages\"\u003e\u003c/span\u003e\u003c/h1\u003e \u003cbutton v-on:click='sj'\u003e点我查看当前时间\u003c/button\u003e \u003c/div\u003e 加了 v-html 指令后的效果： 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-4-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-1/:0:4","tags":["Vue","前端"],"title":"Vue-4-模板语法-1","uri":"/vue-4-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-1/"},{"categories":["Vue简明教程"],"content":"HTML 属性渲染 指令：v-bind:xx 当我们需要在代码运行过程中修改元素属性时，我们可以采用 v-bind 对 HTML 元素属性进行修改。 未绑定元素 ID 前的页面： 页面效果\" 页面效果 绑定属性代码（HTML）： \u003cdiv id=\"app\"\u003e \u003ch1 v-bind:id=\"demoId\"\u003e\u003cspan v-html=\"messages\"\u003e\u003c/span\u003e\u003c/h1\u003e \u003cbutton v-on:click='sj'\u003e点我查看当前时间\u003c/button\u003e \u003c/div\u003e 绑定属性代码（JS）： var app1 = new Vue ( { el: '#app', data: { messages: 'hello Vue!', demoId: 'HId' }, methods:{ sj: function(){ this.messages='当前时间：' + new Date().toLocaleTimeString() } } } ) 绑定元素 ID 后的页面： 绑定ID\" 绑定ID 修改 Vue 属性 demoId 值后的页面： 页面效果\" 页面效果 页面效果\" 页面效果 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-4-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-1/:0:5","tags":["Vue","前端"],"title":"Vue-4-模板语法-1","uri":"/vue-4-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-1/"},{"categories":["Vue简明教程"],"content":" 续上节，我们可以通过模板语法接收 Vue 的数据渲染，也可以通过 Vue 的指令实现不同类型的数据渲染和 HTML 属性的动态修改。 例：按钮的条件使能 假设，目前有一个需求是某个按钮需要根据某个字段的值进行使能和禁用。 ","date":"2021-06-15","objectID":"/vue-5-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-2/:0:0","tags":["Vue","前端"],"title":"Vue-5-模板语法-2","uri":"/vue-5-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-2/"},{"categories":["Vue简明教程"],"content":"代码 HTML 代码 \u003cdiv id=\"app5\"\u003e \u003cbutton v-bind:disabled=\"yy\"\u003e{{ msg }}\u003c/button\u003e \u003c/div\u003e JS 代码 var msg='点我' var app5 =new Vue({ el: '#app5', data: { yy: 'true', msg: msg } }) ","date":"2021-06-15","objectID":"/vue-5-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-2/:0:1","tags":["Vue","前端"],"title":"Vue-5-模板语法-2","uri":"/vue-5-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-2/"},{"categories":["Vue简明教程"],"content":"页面效果 页面效果\" 页面效果 修改 Vue 实例的 yy 值为 false： 页面效果\" 页面效果 Vue 指令的缩写 v-作为 Vue 专属的视觉提示，用来标识 Vue 接管的元素，当你熟悉了 Vue 特性和项目全部在使用 Vue 前段框架的时候，我们可以使用 Vue 指令的缩写来简化代码。 ","date":"2021-06-15","objectID":"/vue-5-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-2/:0:2","tags":["Vue","前端"],"title":"Vue-5-模板语法-2","uri":"/vue-5-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-2/"},{"categories":["Vue简明教程"],"content":"v-bind 缩写 缩写格式：: \u003c!-- 完整语法 --\u003e \u003ca v-bind:href=\"url\"\u003e...\u003c/a\u003e \u003c!-- 缩写 --\u003e \u003ca :href=\"url\"\u003e...\u003c/a\u003e \u003c!-- 动态参数的缩写 (2.6.0+) --\u003e \u003ca :[key]=\"url\"\u003e ... \u003c/a\u003e ","date":"2021-06-15","objectID":"/vue-5-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-2/:0:3","tags":["Vue","前端"],"title":"Vue-5-模板语法-2","uri":"/vue-5-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-2/"},{"categories":["Vue简明教程"],"content":"v-on 缩写 缩写格式：@ \u003c!-- 完整语法 --\u003e \u003ca v-on:click=\"doSomething\"\u003e...\u003c/a\u003e \u003c!-- 缩写 --\u003e \u003ca @click=\"doSomething\"\u003e...\u003c/a\u003e \u003c!-- 动态参数的缩写 (2.6.0+) --\u003e \u003ca @[event]=\"doSomething\"\u003e ... \u003c/a\u003e 在上面的动态参数缩写示例中，当 event 的值为 \"focus\" 时，@:[event] 将等价于 v-on:focus，即：当元素被聚焦时触发 doSomething。 Tip Vue 也支持了 js 在模板语法中的执行。 Vue 可以让我们对 HTML 元素的属性，比如 ID，URl，Class 等属性进行灵活的按需修改。 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-5-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-2/:0:4","tags":["Vue","前端"],"title":"Vue-5-模板语法-2","uri":"/vue-5-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-2/"},{"categories":["Vue简明教程"],"content":"什么是计算属性 理论上在模板的插值表达式中，我们可以进行简单运算，但是在模板表达式中加入太多的逻辑，会让模板太复杂不方便维护。 实践 ","date":"2021-06-15","objectID":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/:0:0","tags":["Vue","前端"],"title":"Vue-6-计算属性","uri":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"demo1 当我们想要根据出生年份来计算年龄的时候，我们可以这样做： ","date":"2021-06-15","objectID":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/:1:0","tags":["Vue","前端"],"title":"Vue-6-计算属性","uri":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"代码-HTML \u003cdiv id=\"app1\"\u003e phyger的年龄是多少？ \u003cbr\u003e {{ 2021-Number(birth) }} \u003c/div\u003e ","date":"2021-06-15","objectID":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/:1:1","tags":["Vue","前端"],"title":"Vue-6-计算属性","uri":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"代码-JS \u003cscript\u003e var integer var app = new Vue({ el: \"#app1\", data: { birth: 1992 } }) \u003c/script\u003e ","date":"2021-06-15","objectID":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/:1:2","tags":["Vue","前端"],"title":"Vue-6-计算属性","uri":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"页面效果 页面效果\" 页面效果 如上，2001 年出生的孩子，今年应该是 20 岁。 以上方式，我们在模板插值表达式中进行了计算，现在我们使用 Vue 的计算属性来对它进行替代。 ","date":"2021-06-15","objectID":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/:1:3","tags":["Vue","前端"],"title":"Vue-6-计算属性","uri":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"代码-HTML \u003cdiv id=\"app1\"\u003e phyger的年龄是多少？ \u003cbr\u003e {{ age }} \u003c/div\u003e ","date":"2021-06-15","objectID":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/:1:4","tags":["Vue","前端"],"title":"Vue-6-计算属性","uri":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"代码-JS \u003cscript\u003e var integer var app = new Vue({ el: \"#app1\", data: { birth: 1992 }, computed: { age: function(){ return 2021-this.birth } } }) \u003c/script\u003e ","date":"2021-06-15","objectID":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/:1:5","tags":["Vue","前端"],"title":"Vue-6-计算属性","uri":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"页面效果 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/:1:6","tags":["Vue","前端"],"title":"Vue-6-计算属性","uri":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"demo2 根据出生日期计算年龄。 ","date":"2021-06-15","objectID":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/:2:0","tags":["Vue","前端"],"title":"Vue-6-计算属性","uri":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"代码-HTML \u003cdiv id=\"app1\"\u003e 根据出生年份计算年龄！ \u003cinput type=\"datetime\" v-model=\"birth\"/\u003e \u003cbr\u003e {{ age }} \u003c/div\u003e ","date":"2021-06-15","objectID":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/:2:1","tags":["Vue","前端"],"title":"Vue-6-计算属性","uri":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"代码-JS \u003cscript\u003e var app = new Vue({ el: \"#app1\", data: { birth: 1992 }, computed: { age: function(){ console.log('computed start...') return 2021-this.birth } }, }) \u003c/script\u003e ","date":"2021-06-15","objectID":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/:2:2","tags":["Vue","前端"],"title":"Vue-6-计算属性","uri":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"效果 输入出生年份自动计算出年龄输入出生年份自动计算出年龄 \" 输入出生年份自动计算出年龄 问题 如果我们使用一个非响应式的对象，比如 Data，那么当 Vue 的属性发生变化时，这个非响应式的对象会变吗？ ","date":"2021-06-15","objectID":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/:2:3","tags":["Vue","前端"],"title":"Vue-6-计算属性","uri":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"代码-HTML \u003cdiv id=\"app1\"\u003e 根据出生年份计算年龄！ \u003cinput type=\"datetime\" v-model=\"birth\"/\u003e \u003cbr\u003e {{ age }} \u003c/div\u003e ","date":"2021-06-15","objectID":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/:2:4","tags":["Vue","前端"],"title":"Vue-6-计算属性","uri":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"代码-JS \u003cscript\u003e const nowDate = new Date(); var app = new Vue({ el: \"#app1\", data: { birth: 1992 }, computed: { age: function(){ console.log('computed start...') //return 2021-this.birth return nowDate.getSeconds() } }, }) \u003c/script\u003e ","date":"2021-06-15","objectID":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/:2:5","tags":["Vue","前端"],"title":"Vue-6-计算属性","uri":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"效果 你会发现，当输入框的值发生变化的时候，Vue 的 age 属性未发生变化。 页面效果age为10 \" 页面效果 页面效果age依然为10 \" 页面效果 具体原因我们下节继续分析。 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/:2:6","tags":["Vue","前端"],"title":"Vue-6-计算属性","uri":"/vue-6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"什么是侦听属性 上节，我们已经了解了计算属性和方法的区别，其实在 Vue 中还有一种可以根据 Vue 实例的数据而实时变化的属性，即侦听属性。由于这种属性的好处，你可能会滥用它，导致代码的臃肿。某些时候可能使用计算属性更合适。 实例 ","date":"2021-06-15","objectID":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["Vue","前端"],"title":"Vue-7-计算属性和方法的区别","uri":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"侦听属性 ","date":"2021-06-15","objectID":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/:1:0","tags":["Vue","前端"],"title":"Vue-7-计算属性和方法的区别","uri":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"代码-HTML \u003cdiv id='app2'\u003e {{ info }} \u003c/div\u003e ","date":"2021-06-15","objectID":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/:1:1","tags":["Vue","前端"],"title":"Vue-7-计算属性和方法的区别","uri":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"代码-JS \u003cscript\u003e var app2 = new Vue({ el: \"#app2\", data: { msg1: \"hello\", msg2: \"phyger\", info: \"hello phyger\" }, watch:{ msg1: function(){ this.info = this.msg1 + ' ' + this.msg2 }, msg2: function(){ this.info = this.msg1 + ' ' + this.msg2 } } }) \u003c/script\u003e ","date":"2021-06-15","objectID":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/:1:2","tags":["Vue","前端"],"title":"Vue-7-计算属性和方法的区别","uri":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"页面效果 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/:1:3","tags":["Vue","前端"],"title":"Vue-7-计算属性和方法的区别","uri":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"过程分析 如上，你会发现使用侦听属性在处理字符拼接的时候，定义了两个侦听属性，但是如果选择计算属性，则会简单甚多。 ","date":"2021-06-15","objectID":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/:1:4","tags":["Vue","前端"],"title":"Vue-7-计算属性和方法的区别","uri":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"计算属性 ","date":"2021-06-15","objectID":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/:2:0","tags":["Vue","前端"],"title":"Vue-7-计算属性和方法的区别","uri":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"代码-HTML \u003cdiv id='app2'\u003e {{ infoc }} \u003c/div\u003e ","date":"2021-06-15","objectID":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/:2:1","tags":["Vue","前端"],"title":"Vue-7-计算属性和方法的区别","uri":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"代码-JS \u003cscript\u003e var app2 = new Vue({ el: \"#app2\", data: { msg1: \"hello\", msg2: \"phyger\", info: \"hello phyger\" }, watch:{ msg1: function(){ this.info = this.msg1 + ' ' + this.msg2 }, msg2: function(){ this.info = this.msg1 + ' ' + this.msg2 } }, computed: { infoc: function(){ return this.msg1+' '+this.msg2 } } }) \u003c/script\u003e ","date":"2021-06-15","objectID":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/:2:2","tags":["Vue","前端"],"title":"Vue-7-计算属性和方法的区别","uri":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"页面效果 页面效果\" 页面效果 总结 侦听属性是针对单个属性的监听，即需要监听几个属性，就得写几个侦听方法；而计算属性可以以表达式的方式出现，即可以监控多个属性。侦听属性精确单一，计算属性一次到位。 关于侦听属性和计算属性的区别，你学废了吗？ 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/:2:3","tags":["Vue","前端"],"title":"Vue-7-计算属性和方法的区别","uri":"/vue-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Vue简明教程"],"content":"什么是侦听属性 上节，我们已经了解了计算属性和方法的区别，其实在 Vue 中还有一种可以根据 Vue 实例的数据而实时变化的属性，即侦听属性。由于这种属性的好处，你可能会滥用它，导致代码的臃肿。某些时候可能使用计算属性更合适。 实例 ","date":"2021-06-15","objectID":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/:0:0","tags":["Vue","前端"],"title":"Vue-8-计算属性和侦听属性","uri":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"侦听属性 ","date":"2021-06-15","objectID":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/:1:0","tags":["Vue","前端"],"title":"Vue-8-计算属性和侦听属性","uri":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"代码-HTML \u003cdiv id='app2'\u003e {{ info }} \u003c/div\u003e ","date":"2021-06-15","objectID":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/:1:1","tags":["Vue","前端"],"title":"Vue-8-计算属性和侦听属性","uri":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"代码-JS \u003cscript\u003e var app2 = new Vue({ el: \"#app2\", data: { msg1: \"hello\", msg2: \"phyger\", info: \"hello phyger\" }, watch:{ msg1: function(){ this.info = this.msg1 + ' ' + this.msg2 }, msg2: function(){ this.info = this.msg1 + ' ' + this.msg2 } } }) \u003c/script\u003e ","date":"2021-06-15","objectID":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/:1:2","tags":["Vue","前端"],"title":"Vue-8-计算属性和侦听属性","uri":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"页面效果 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/:1:3","tags":["Vue","前端"],"title":"Vue-8-计算属性和侦听属性","uri":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"过程分析 如上，你会发现使用侦听属性在处理字符拼接的时候，定义了两个侦听属性，但是如果选择计算属性，则会简单甚多。 ","date":"2021-06-15","objectID":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/:1:4","tags":["Vue","前端"],"title":"Vue-8-计算属性和侦听属性","uri":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"计算属性 ","date":"2021-06-15","objectID":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/:2:0","tags":["Vue","前端"],"title":"Vue-8-计算属性和侦听属性","uri":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"代码-HTML \u003cdiv id='app2'\u003e {{ infoc }} \u003c/div\u003e ","date":"2021-06-15","objectID":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/:2:1","tags":["Vue","前端"],"title":"Vue-8-计算属性和侦听属性","uri":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"代码-JS \u003cscript\u003e var app2 = new Vue({ el: \"#app2\", data: { msg1: \"hello\", msg2: \"phyger\", info: \"hello phyger\" }, watch:{ msg1: function(){ this.info = this.msg1 + ' ' + this.msg2 }, msg2: function(){ this.info = this.msg1 + ' ' + this.msg2 } }, computed: { infoc: function(){ return this.msg1+' '+this.msg2 } } }) \u003c/script\u003e ","date":"2021-06-15","objectID":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/:2:2","tags":["Vue","前端"],"title":"Vue-8-计算属性和侦听属性","uri":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"页面效果 页面效果\" 页面效果 总结 侦听属性是针对单个属性的监听，即需要监听几个属性，就得写几个侦听方法；而计算属性可以以表达式的方式出现，即可以监控多个属性。侦听属性精确单一，计算属性一次到位。 关于侦听属性和计算属性的区别，你学废了吗？ 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/:2:3","tags":["Vue","前端"],"title":"Vue-8-计算属性和侦听属性","uri":"/vue-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"计算属性的属性 默认的，计算属性实现了 getter 属性，我们可以直接拿到计算属性的值。但是如果尝试对计算属性的值进行修改，会成功吗？ 如上，不出意外的在对计算属性进行 setter 操作的时候失败了，Vue 提示我们计算属性 infoc 没有 setter 属性。 实现计算属性的 setter 属性 ","date":"2021-06-15","objectID":"/vue-9-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7/:0:0","tags":["Vue","前端"],"title":"Vue-9-计算属性的属性","uri":"/vue-9-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"代码-HTMl \u003cdiv id='app2'\u003e {{ infoc }} \u003c/div\u003e ","date":"2021-06-15","objectID":"/vue-9-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7/:0:1","tags":["Vue","前端"],"title":"Vue-9-计算属性的属性","uri":"/vue-9-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"代码-JS \u003cscript\u003e var app2 = new Vue({ el: \"#app2\", data: { msg1: \"hello\", msg2: \"phyger\", info: \"hello phyger\" }, watch:{ msg1: function(){ this.info = this.msg1 + ' ' + this.msg2 }, msg2: function(){ this.info = this.msg1 + ' ' + this.msg2 } }, computed: { infoc:{ get: function(){ return this.msg1+' '+this.msg2 }, set: function(newValue){ var temInfo = newValue.split(' ') this.msg1=temInfo[0] this.msg2=temInfo[temInfo.length-1] } } } }) \u003c/script\u003e ","date":"2021-06-15","objectID":"/vue-9-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7/:0:2","tags":["Vue","前端"],"title":"Vue-9-计算属性的属性","uri":"/vue-9-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"页面效果 可以看到，在计算属性中实现 setter 属性后，计算属性已经可以进行赋值操作了。而且在赋值过程中，msg1 和 msg2 的值都发生了变化。 Tip 在计算属性中定义 setter 属性的时候，infoc 已经由原来的方法变成了方法的集合。且默认的 getter 属性也要重新定义。 ","date":"2021-06-15","objectID":"/vue-9-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7/:0:3","tags":["Vue","前端"],"title":"Vue-9-计算属性的属性","uri":"/vue-9-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7/"},{"categories":["Vue简明教程"],"content":"不定义会如何？ 如果不重新定义，则 Vue 对象会由于 Getter 属性的缺失而无法渲染： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript crossorigin=\"anonymous\" integrity=\"sha512-qRXBGtdrMm3Vdv+YXYud0bixlSfZuGz+FmD+vfXuezWYfw4m5Ov0O4liA6UAlKw2rh9MOYULxbhSFrQCsF1hgg==\" src=\"https://lib.baomitu.com/vue/2.6.14/vue.common.dev.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app2\"\u003e {{ infoc }} \u003c/div\u003e \u003cscript\u003e var app2 = new Vue({ el: \"#app2\", data: { msg1: \"hello\", msg2: \"phyger\", info: \"hello phyger\" }, watch:{ msg1: function(){ this.info = this.msg1 + ' ' + this.msg2 }, msg2: function(){ this.info = this.msg1 + ' ' + this.msg2 } }, computed: { infoc:{ // get: function(){ // return this.msg1+' '+this.msg2 // }, set: function(newValue){ var temInfo = newValue.split(' ') this.msg1=temInfo[0] this.msg2=temInfo[temInfo.length-1] } } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Getter属性缺失提示Getter属性缺失 \" Getter属性缺失 将 get 属性的注释去掉 页面已经渲染正常页面已经渲染正常 \" 页面已经渲染正常 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-9-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7/:1:0","tags":["Vue","前端"],"title":"Vue-9-计算属性的属性","uri":"/vue-9-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7/"},{"categories":null,"content":"Title 野生程序员 Major CloudNative、Python Email 463551098@qq.com More 公众号：Python研究所 扫码关注 ","date":"2021-06-11","objectID":"/about/:0:0","tags":null,"title":"关于博主","uri":"/about/"}]