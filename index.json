[{"categories":["Python","Python进阶"],"content":"通常，当我们需要对对象的敏感属性或者不希望外部直接访问的属性进行私有化，但是某些时候我们又需要对这些私有属性进行修改，该怎么处理呢？ 1、几个概念 _a(前置单下划线)，这种属性仅表示约定的私有，非真正的私有。 __a(前置双下划线)，这种属性表示私有，无法在外部访问。 _a_(前后双下划线)，这种属性标识系统属性。(可选) a_(后置单下划线)，这种属性是为了避免和保留关键字冲突。(可选) 2、举个例子 ","date":"2021-07-15","objectID":"/python%E7%9A%84property%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:0:0","tags":["Python","装饰器"],"title":"Python的@property是干嘛的？","uri":"/python%E7%9A%84property%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶"],"content":"定义一个类： class Student(object): _sex='male' __age=0 执行：（私有属性无法在外部访问） \u003e\u003e\u003e stu = Student() \u003e\u003e\u003e stu._sex 'male' \u003e\u003e\u003e stu.__age Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e AttributeError: 'Student' object has no attribute '__age' \u003e\u003e\u003e 3、解决问题 从上面的类中我们可以看到，私有属性无法在类实例中访问，怎么办呢？当我们需要对类的私有属性__age进行查询和修改的时候，我们可以定义get_age和set_age去实现。 class Student(object): _sex='male' __age=0 def get_age(self): return self.__age def set_age(self,age): self.__age = age 执行： \u003e\u003e\u003e stu = Student() \u003e\u003e\u003e stu.get_age() 0 \u003e\u003e\u003e stu.set_age(18) \u003e\u003e\u003e stu.get_age() 18 \u003e\u003e\u003e 4、换个方法 但是上面的这种方式略显复杂，如果在私有属性较多的类中就不太适用了，所以我们期望寻求一种更简单的方式去解决这个问题，比如将这个私有属性转化为另一个属性。告诉你个好消息，Python已经帮我们实现了，这就是@property。 class Student(object): _sex='male' __age=0 def get_age(self): return self.__age def set_age(self,age): self.__age = age @property def age(self): return self.__age 执行： \u003e\u003e\u003e from payhlib import Student \u003e\u003e\u003e s = Student() \u003e\u003e\u003e s.age 0 \u003e\u003e\u003e s.set_age(19) \u003e\u003e\u003e s.age 19 \u003e\u003e 在上面我们将__age私有属性转换为了age属性，你可能会想，既然私有属性转换为了属性，那我们是不是可以直接修改它呢？答案是不行，因为property虽然将__age转换为了属性，但是其不具备setter功能，需要我们去添加。 \u003e\u003e\u003e from payhlib import Student \u003e\u003e\u003e s = Student() \u003e\u003e\u003e s.age 0 \u003e\u003e\u003e s.age=20 Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e AttributeError: can't set attribute \u003e\u003e\u003e 添加setter方法 class Student(object): _sex='male' __age=0 def get_age(self): return self.__age def set_age(self,age): self.__age = age @property def age(self): return self.__age @age.setter def age(self,value): self.__age=value 执行： \u003e\u003e\u003e from payhlib import Student \u003e\u003e\u003e s = Student() \u003e\u003e\u003e s.age 0 \u003e\u003e\u003e s.age=20 \u003e\u003e\u003e s.age 20 \u003e\u003e\u003e 到此，@peoperty分享完毕，关于它的实现原理你可以查看源码进行研究。 图片 ","date":"2021-07-15","objectID":"/python%E7%9A%84property%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:1:0","tags":["Python","装饰器"],"title":"Python的@property是干嘛的？","uri":"/python%E7%9A%84property%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶"],"content":" 相信你一定知道继承，多态和封装。封装通常是为了提供统一接口而将具体实现过程或者属性以方法或者类的方式对外呈现；继承就是子类继承父类从而拥有父类的方法和属性；多态是继承了同一个父类的不同子类分别重写了父类的某个方法而使得这个方法在不同的子类中有不同的实现。 多重继承即子类继承多个父类，拥有多个父类的方法和属性。 1、封装 比如我们想实现输入两个数字就可以计算其乘积。 ","date":"2021-07-15","objectID":"/python%E7%9A%84%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:0:0","tags":["Python","装饰器"],"title":"Python的封装继承多态和多重继承","uri":"/python%E7%9A%84%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶"],"content":"第一种方式： def ret2x(x,y): sum=0 while x\u003e0: sum+=y x-=1 return sum \u003e\u003e\u003e ret2x(2,8) 16 \u003e\u003e\u003e ret2x(90,8) 720 \u003e\u003e\u003e ","date":"2021-07-15","objectID":"/python%E7%9A%84%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:1:0","tags":["Python","装饰器"],"title":"Python的封装继承多态和多重继承","uri":"/python%E7%9A%84%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶"],"content":"第二种方式： def ret2x(x,y): return x*y \u003e\u003e\u003e ret2x(2,8) 16 \u003e\u003e\u003e ret2x(90,8) 720 \u003e\u003e\u003e 可以看到执行结果一毛一样，对于使用者来说，不关注也看不到ret2x的具体实现，只需要调用拿到结果即可。 2、继承 ","date":"2021-07-15","objectID":"/python%E7%9A%84%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:2:0","tags":["Python","装饰器"],"title":"Python的封装继承多态和多重继承","uri":"/python%E7%9A%84%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶"],"content":"定义Chinese类继承Human类： class Human(object): hum = '人类' def kind(self): print(\"人类...\") class Chinese(Human): chin = '中国人' 执行： \u003e\u003e\u003e from payhlib import Chinese \u003e\u003e\u003e c = Chinese() \u003e\u003e\u003e c.hum '人类' \u003e\u003e\u003e c.chin '中国人' \u003e\u003e\u003e c.kind() 人类... \u003e\u003e\u003e Chinese类继承了Human类，所以Chinese的对象拥有了Human父类的hum属性和kind方法。 3、多态 ","date":"2021-07-15","objectID":"/python%E7%9A%84%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:3:0","tags":["Python","装饰器"],"title":"Python的封装继承多态和多重继承","uri":"/python%E7%9A%84%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶"],"content":"继续在继承的基础上进行演示： class Human(object): hum = '人类' def kind(self): print(\"人类...\") def country(self): pass class Chinese(Human): chin = '中国人' def country(self): print('北京') class Japanese(Human): jap = '日本人' def country(self): print('东京') Chinese类和Japanese类分别实现了父类Human的country方法。 执行： \u003e\u003e\u003e from payhlib import * \u003e\u003e\u003e a = Chinese() \u003e\u003e\u003e b = Japanese() \u003e\u003e\u003e a.country() 北京 \u003e\u003e\u003e b.country() 东京 \u003e\u003e\u003e a.kind() 人类... \u003e\u003e\u003e b.kind() 人类... \u003e\u003e\u003e 中国人和日本人都是人类，但是中国的首都是北京，日本的首都是东京。 4、多重继承 讲了这么多，现在进入正题，我们都知道世界上人类按照性别可以分为男和女。如果我们于上面的Chinese类和Japanese增加性别相关属性和方法，就可以通过多重继承实现。 class Human(object): hum = '人类' def kind(self): print(\"人类...\") def country(self): pass class Sex(object): summary = '性别类' def male(self): print('男人') def female(self): print('女人') class Chinese(Human,Sex): chin = '中国人' def country(self): print('北京') class Japanses(Human,Sex): jap = '日本人' def country(self): print('东京') 执行： \u003e\u003e\u003e from payhlib import * \u003e\u003e\u003e a = Chinese() \u003e\u003e\u003e b = Japanses() \u003e\u003e\u003e a.kind() 人类... \u003e\u003e\u003e b.kind() 人类... \u003e\u003e\u003e a.male() 男人 \u003e\u003e\u003e b.female() 女人 \u003e\u003e\u003e a.hum '人类' \u003e\u003e\u003e a.summary '性别类' \u003e\u003e\u003e Chinese类即拥有Human类的方法属性，也拥有Sex类的方法和属性。 ","date":"2021-07-15","objectID":"/python%E7%9A%84%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:4:0","tags":["Python","装饰器"],"title":"Python的封装继承多态和多重继承","uri":"/python%E7%9A%84%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶"],"content":"多重继承+多态的效果： class Human(object): hum = '人类' def kind(self): print(\"人类...\") def country(self): pass class Sex(object): summary = '性别类' def male(self): print('男人') def female(self): print('女人') class Chinese(Human,Sex): chin = '中国人' def country(self): print('北京') def male(self): print('中国男人') def female(self): print('中国女人') class Japanses(Human,Sex): jap = '日本人' def country(self): print('东京') def male(self): print('日本男人') def female(self): print('日本女人') 执行： \u003e\u003e\u003e from payhlib import * \u003e\u003e\u003e a = Chinese() \u003e\u003e\u003e b = Japanses() \u003e\u003e\u003e a.kind() 人类... \u003e\u003e\u003e b.kind() 人类... \u003e\u003e\u003e a.country() 北京 \u003e\u003e\u003e b.country() 东京 \u003e\u003e\u003e a.male() 中国男人 \u003e\u003e\u003e b.male() 日本男人 \u003e\u003e\u003e a.female() 中国女人 \u003e\u003e\u003e b.female() 日本女人 \u003e\u003e\u003e a.summary '性别类' \u003e\u003e\u003e b.summary '性别类' \u003e\u003e\u003e Chinese类和Japanese类同时继承了Human类和Sex类，所有Chinese的对象和Japanese的对象就拥有了Human和Sex的属性和方法，但是他们又分别重写了父类的country和male即female方法。这种多重继承的方式也称MixIn（混入）。 ","date":"2021-07-15","objectID":"/python%E7%9A%84%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:5:0","tags":["Python","装饰器"],"title":"Python的封装继承多态和多重继承","uri":"/python%E7%9A%84%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶"],"content":"什么是闭包 Python中的闭包是一个比较模糊的概念，有很多朋友都认为不好理解，但是随着深入学习，就会发现闭包无论如何都是需要去理解的，下面我将自己对闭包的理解进行阐述，希望能够对你有所帮助 ~ 我们可以将闭包理解为一种特殊的函数，这种函数由两个函数的嵌套组成，且称之为外函数和内函数，外函数返回值是内函数的引用，此时就构成了闭包。 闭包的格式 如下： def 外层函数(参数): def 内层函数(): print(\"内层函数执行\", 参数) return 内层函数 内层函数的引用 = 外层函数(\"传入参数\") 内层函数的引用() 外层函数中的参数，不一定要有，据情况而定，但是一般情况下都会有并在内函数中使用到 闭包的实例 如下： def outfunc(a): # 定义外函数 def infunc(b): # 定义内函数 return a*b # 内函数的返回值 return infunc # 外函数的返回值，返回内函数的对象 func_instance = outfunc(8) # 外函数的实例，是一个function对象 print(type(func_instance)) # 打印外函数实例的类型 res = func_instance(10) # 外函数实例的调用 print(res) 输出 ➜ test git:(master) ✗ python3 testpy.py \u003cclass 'function'\u003e 80 在上面的代码中，内函数直接使用了外函数的变量值，那如果想要在内函数中对外函数的变量值进行修改，怎么操作呢？ 修改外函数的变量值 想要修改外函数的变量值，需要用到nonlocal关键字。 def outfunc(a): def infunc(b): nonlocal a a = a*2 return a*b return infunc func_instance = outfunc(8) print(type(func_instance)) res = func_instance(10) print(res) 输出 ➜ test git:(master) ✗ python3 testpy.py \u003cclass 'function'\u003e 160 如上即可。 闭包的使用场景 Python中，闭包的主要用途就是用于装饰器的实现。后续讲解。 还有就是可以简化参数重复传递，比如： def add(a,b,c): print(a*b*c) add(1,2,1) add(1,2,2) add(1,2,3) add(1,2,4) add(1,2,5) 输出 ➜ test git:(master) ✗ python3 testpy.py 2 4 6 8 10 你会发现，a和b是固定不变的，我们怎么样才能减少a和b的传参，而只改变c的值呢？这个时候闭包就起到了作用。 def addNew(a,b): def addC(c): return a*b*c return addC func_ins = addNew(1,2) print(func_ins(1)) print(func_ins(2)) print(func_ins(3)) print(func_ins(4)) print(func_ins(5)) 输出 ➜ test git:(master) ✗ python3 testpy.py 2 4 6 8 10 ","date":"2021-07-15","objectID":"/%E9%97%AD%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:0:0","tags":["Python","闭包"],"title":"Python的闭包是什么？","uri":"/%E9%97%AD%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶"],"content":"基本的魔法方法 名称 解释 _new_(cls[, …]) 在一个对象实例化的时候所调用的第一个方法 _init_(self[, …]) 构造器，当一个实例被创建的时候调用的初始化方法 _del_(self) 析构器，当一个实例被销毁的时候调用的方法 _call_(self[, args…]) 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.call(a, b) _len_(self) 定义当被 len() 调用时的行为 _repr_(self) 定义当被 repr() 调用时的行为 _str_(self) 定义当被 str() 调用时的行为 _bytes_(self) 定义当被 bytes() 调用时的行为 _hash_(self) 定义当被 hash() 调用时的行为 _bool_(self) 定义当被 bool() 调用时的行为，应该返回 True 或 False _format_(self, format_spec) 定义当被 format() 调用时的行为 有关属性 名称 解释 _getattr_(self, name) 定义当用户试图获取一个不存在的属性时的行为 _getattribute_(self, name) 定义当该类的属性被访问时的行为 _setattr_(self, name, value) 定义当一个属性被设置时的行为 _delattr_(self, name) 定义当一个属性被删除时的行为 _dir_(self) 定义当 dir() 被调用时的行为 _get_(self, instance, owner) 定义当描述符的值被取得时的行为 _set_(self, instance, value) 定义当描述符的值被改变时的行为 _delete_(self, instance) 定义当描述符的值被删除时的行为 比较操作符 名称 解释 _lt_(self, other) 定义小于号的行为：x \u003c y 调用 x.lt(y) _le_(self, other) 定义小于等于号的行为：x \u003c= y 调用 x.le(y) _eq_(self, other) 定义等于号的行为：x == y 调用 x.eq(y) _ne_(self, other) 定义不等号的行为：x != y 调用 x.ne(y) _gt_(self, other) 定义大于号的行为：x \u003e y 调用 x.gt(y) _ge_(self, other) 定义大于等于号的行为：x \u003e= y 调用 x.ge(y) 算数运算符 名称 解释 _add_(self, other) 定义加法的行为：+ _sub_(self, other) 定义减法的行为：- _mul_(self, other) 定义乘法的行为：* _truediv_(self, other) 定义真除法的行为：/ _floordiv_(self, other) 定义整数除法的行为：// _mod_(self, other) 定义取模算法的行为：% _divmod_(self, other) 定义当被 divmod() 调用时的行为 _pow_(self, other[, modulo]) 定义当被 power() 调用或 ** 运算时的行为 _lshift_(self, other) 定义按位左移位的行为：« _rshift_(self, other) 定义按位右移位的行为：» _and_(self, other) 定义按位与操作的行为：\u0026 _xor_(self, other) 定义按位异或操作的行为：^ _or_(self, other) 定义按位或操作的行为： 反运算 名称 解释 _radd_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rsub_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rmul_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rtruediv_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rfloordiv_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rmod_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rdivmod_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rpow_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rlshift_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rrshift_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rand_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _rxor_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） _ror_(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） 增量赋值运算 名称 解释 _iadd_(self, other) 定义赋值加法的行为：+= _isub_(self, other) 定义赋值减法的行为：-= _imul_(self, other) 定义赋值乘法的行为：*= _itruediv_(self, other) 定义赋值真除法的行为：/= _ifloordiv_(self, other) 定义赋值整数除法的行为：//= _imod_(self, other) 定义赋值取模算法的行为：%= _ipow_(self, other[, modulo]) 定义赋值幂运算的行为：**= _ilshift_(self, other) 定义赋值按位左移位的行为：«= _irshift_(self, other) 定义赋值按位右移位的行为：»= _iand_(self, other) 定义赋值按位与操作的行为：\u0026= _ixor_(self, other) 定义赋值按位异或操作的行为：^= _ior_(self, other) 定义赋值按位或操作的行为： 一元操作符 名称 解释 _pos_(self) 定义正号的行为：+x _neg_(self) 定义负号的行为：-x _abs_(self) 定义当被 abs() 调用时的行为 _invert_(self) 定义按位求反的行为：~x 类型转换 名称 解释 _complex_(self) 定义当被 complex() 调用时的行为（需要返回恰当的值） _int_(self) 定义当被 int() 调用时的行为（需要返回恰当的值） _float_(self) 定义当被 float() 调用时的行为（需要返回恰当的值） _round_(self[, n]) 定义当被 round() 调用时的行为（需要返回恰当的值） _index_(self) 1. 当对象是被应用在切片表达式中时，实现整形强制转换 2. 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 index 3. 如果 index 被定义，则 int 也需要被定义，且返回相同的值 上下文管理（with 语句） 名称 解释 _enter_(self) 1. 定义当使用 with 语句时的初始化行为 2. enter 的返回值被 with 语句的目标或者 as 后的名字绑定 _exit_(self, exc_type, exc_value, traceback) 1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么 2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 容器类型 名称 解释 _len_(self) 定义当被 len() 调用时的行为（返回容器中元素的个数） _getitem_(self, key) 定义获取容器中指定元素的行为，相当于 self[key] _setitem_(self, key, value) 定义设置容器中指定元素的行为，相当于 self[key] = value _delitem_(self, key) 定义删除容器中指定元素的行为，相当于 del self[key] _iter_(self) 定义当迭代容器中的元素的行为 _reversed_(self) 定义当被 reversed() 调用时的行为 _contains_(self, item) 定义当使用成员测试运算符（in 或 not in）时的行为 ","date":"2021-07-15","objectID":"/%E5%B9%B2%E8%B4%A7python%E7%9A%84%E9%AD%94%E6%95%B0%E6%96%B9%E6%B3%95%E4%B8%80%E8%A7%88%E8%A1%A8-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:0:0","tags":["Python","魔法方法"],"title":"Python的魔法方法一览表","uri":"/%E5%B9%B2%E8%B4%A7python%E7%9A%84%E9%AD%94%E6%95%B0%E6%96%B9%E6%B3%95%E4%B8%80%E8%A7%88%E8%A1%A8-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶"],"content":"接【简明】彻底搞清楚Python的装饰器，我们继续介绍类装饰器+带参数的装饰+多装饰器，顾名思义类装饰器就是类闭包。 定义一个类装饰器 需求：实现一个类装饰器，能够在方法执行时打印日志，并且发送通知到指定地方。 from functools import wraps class logAndNotify(object): # 初始化，定义日志路径 def __init__(self,logfile='service.log'): self.logfile = logfile # 使类成为可调用对象 def __call__(self,func): @wraps(func) def wrap_func(*args,**kwargs): info = func.__name__+'was called' # 实现写日志 with open(self.logfile,'a') as f: f.write(info+'\\n') # 实现通知 self.notify() return func(*args,**kwargs) return wrap_func def notify(self): print('notify has been send...') @logAndNotify() def sayHi(name): print('hello',name,'!') res = sayHi('phyger') print(res) 执行结果： ➜ RemoteWorking git:(master) ✗ /usr/bin/python3 /root/RemoteWorking/test/test.py notify has been send... hello phyger ! None 类装饰器功能扩展 如果我们想要在此类装饰器的基础上，增加发送邮件的功能，就可以利用类的继承特性来实现。 from functools import wraps class logAndNotify(object): # 初始化，定义日志路径 def __init__(self, logfile=\"service.log\"): self.logfile = logfile # 使类成为可调用对象 def __call__(self, func): @wraps(func) def wrap_func(*args, **kwargs): info = func.__name__ + \"was called\" # 实现写日志 with open(self.logfile, \"a\") as f: f.write(info + \"\\n\") # 实现通知 self.notify() return func(*args, **kwargs) return wrap_func def notify(self): print(\"notify has been send...\") class NewWarp(logAndNotify): # 初始化邮件地址 def __init__(self, email_address='phyger@qq.com', *args, **kwargs): self.email_address = email_address super(NewWarp,self).__init__(*args, **kwargs) # 重写notify方法 def notify(self): print(\"notify has been send...\") print('email sended...to',self.email_address) @NewWarp() def sayHi(name): print(\"hello\", name, \"!\") res = sayHi(\"phyger\") print(res) 执行结果： ➜ RemoteWorking git:(master) ✗ /usr/bin/python3 /root/RemoteWorking/test/test.py notify has been send... email sended...to phyger@qq.com hello phyger ! None 带参数的装饰器 当我们需要根据不同的场景对函数进行不同的装饰操作的时候，我们需要使用到带参数的装饰器。 例：日志级别控制 import logging from functools import wraps def logg(level): def mid(func): @wraps(func) def inner(*args, **kwargs): # log设置 #logging.basicConfig(format=' %(asctime)s - %(levelname)s -%(message)s') logging.basicConfig(format = '\"%(asctime)s- %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s\"') logger = logging.getLogger() logger.setLevel(level) # logger打印 logger.info('{} start...'.format(func.__name__)) logger.error('{} errors...'.format(func.__name__)) logger.warn('{} warnning...'.format(func.__name__)) logger.debug('{}end...'.format(func.__name__)) return func(*args, **kwargs) return inner return mid @logg(level='DEBUG') def sayHi(name): print('hi,',name) @logg(level='INFO') def sayBye(name): print('bye',name) sayHi(name='phyger') sayBye(name='phyger') 执行输出： ➜ RemoteWorking git:(master) ✗ /usr/bin/python3 /root/RemoteWorking/test/test.py \"2020-10-31 11:23:42,161 - test.py[line:15] - INFO: sayHi start...\" \"2020-10-31 11:23:42,161 - test.py[line:16] - ERROR: sayHi errors...\" \"2020-10-31 11:23:42,162 - test.py[line:17] - WARNING: sayHi warnning...\" \"2020-10-31 11:23:42,162 - test.py[line:18] - DEBUG: sayHiend...\" hi, phyger \"2020-10-31 11:23:42,162 - test.py[line:15] - INFO: sayBye start...\" \"2020-10-31 11:23:42,162 - test.py[line:16] - ERROR: sayBye errors...\" \"2020-10-31 11:23:42,162 - test.py[line:17] - WARNING: sayBye warnning...\" bye phyger 可以看到： 当设置最高级别ERROR的时候，所有级别的日志都打印。 当设置INFO级别的的时候，DEBUG最低级别的日志不打印。 多装饰器 当有多个不能够耦合的功能需要在函数上增加时，我们需要使用多个装饰器，怎么用呢？ 例：实现日志和发送通知的分离 import logging from functools import wraps def wrap1(func): def inner1(*args, **kwargs): print('start') func(*args, **kwargs) print('end') return True return inner1 def wrap2(func): def inner2(*args, **kwargs): print(\"msg has sended...\") func(*args, **kwargs) return True return inner2 @wrap1 @wrap2 def sayHi(name): print('hi',name) sayHi(name='phyher') 执行输出： ➜ RemoteWorking git:(master) ✗ /usr/bin/python3 /root/RemoteWorking/test/test.py start msg has sended... hi phyher end ","date":"2021-07-15","objectID":"/%E9%80%8F%E5%BD%BBpython%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%9B%E9%98%B6%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8-%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8-%E5%A4%9A%E8%A3%85%E9%A5%B0%E5%99%A8-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:0:0","tags":["Python","装饰器"],"title":"Python装饰器进阶（类装饰器+带参数的装饰器+多装饰器）","uri":"/%E9%80%8F%E5%BD%BBpython%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%9B%E9%98%B6%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8-%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8-%E5%A4%9A%E8%A3%85%E9%A5%B0%E5%99%A8-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"什么是 token token（也称令牌）就是一串字符，其作用是为了减轻频繁进行用户名和密码的验证而对服务器产生的压力。客户端首次访问通过正确的用户名和密码从服务端拿到 token，之后客户端携带 token 即可完成验证，无需重复携带用户名和密码。 ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:0","tags":["Python","FastApi","Token"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"JWT JWT 全名 json web token，它是一种开放的标准，其带有数字签名，用于 json 对象的安全传输。 怎么生成 token 我们已经知道 token 是一串字符，我们可以通过一些秘钥+用户名+时间戳等字符组合，使用 base64 对其进行加密，从而生成 token 颁发给客户端。然后对客户端携带的 token 进行解密，拿到秘钥，用户名，时间戳，最后对这些参数进行校验就可以判断 token 正确与否和是否过期。 以上为 token 生成的原理，在实际开发中，我们可以直接使用现成的第三方库（如：python-jose）。 ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:1","tags":["Python","FastApi","Token"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"常用的 JWT 库 python-jose pyjwt jwcrypto authlib ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:2","tags":["Python","FastApi","Token"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"安装 JWT 库 pip install python-jose ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:3","tags":["Python","FastApi","Token"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"生成 token # 从jose导入jwt，后面使用jwt生成token from jose import jwt # 导入日期模块，用来验证token过期时间 from datetime import datetime,timedelta # 定义秘钥，很重要，请勿泄露 SECRET_KEY = 'phyger' # 生成token的代码，token过期时长定义为默认参数，单位为秒 def create_token(seconds=60): # 定义token过期时间，为当前utc时间加上token有效期 expire = datetime.utcnow()+timedelta(seconds=seconds) # 此处即为生成token的payload，sub自定义（可选用户名），uid自定义（可选设备id等） # to_endoe可以是一个空的字典，但是不建议这样做 to_encode = {\"exp\":expire,\"sub\":SECRET_KEY,\"uid\":\"123456\"} # 使用jwt生成token，token是根据payload和秘钥共同生成。 jwt_token = jwt.encode(claims=to_encode,key=SECRET_KEY) return jwt_token jose 的 JWT 默认采用 HS256 加密方式。 运行代码 \u003e python utm.py eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MTI1MjY0OTgsInN1YiI6InBoeWdlciIsInVpZCI6IjEyMzQ1NiJ9.TnRFBFX_2Jn3VU26n603l5uOQyB9bOOWSxBQUr6tBA4 可以看到，token 已经生成。 上面，我们已经介绍了 token 的生成，是直接使用的第三方库 jose，当然 jose 可以生成 token，想必他也可以校验 token 了。 token 校验 ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:4","tags":["Python","FastApi","Token"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"代码 from jose import jwt # 导入token校验的两种异常，一种是token超时异常，一种是token错误异常 from jose.exceptions import ExpiredSignatureError, JWTError def judge_token(token): # 尝试解密，解密成功后，秘钥，payload，有效时长校验通过，则会返回payload try: payload = jwt.decode(token,SECRET_KEY) print(payload) return True # 否则，则捕获异常，进行提示 except ExpiredSignatureError as e: print('token过期了！') return False except JWTError as e: print('token验证失败！') return False 按照传统的 jwt 协议，我们需要解密 token 后，对 token 的秘钥，payload，有效时长进行单独的校验。以上，token 的秘钥，payload，有效时长，jose 都帮我们完成了，我们只需要调用 jose.jwt 的 encode 和 deode 就可以完成加解密。 ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:5","tags":["Python","FastApi","Token"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"执行校验 if __name__ == \"__main__\": tk=create_token() print(tk) res1=judge_token(tk) print(res1) import time time.sleep(60) res2=judge_token(tk) print(res2) 执行结果 \u003e python utm.py eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MTI1Mjg0MzYsInN1YiI6InBoeWdlciIsInVpZCI6IjEyMzQ1NiJ9.yVhoAKyZFvQi3q4wqd1JoRondl9A6wUaALueP00oyhc {'exp': 1612528436, 'sub': 'phyger', 'uid': '123456'} True token过期了！ False``` \u003e 因为默认token的有效期为60秒，我们在第二次校验token前睡眠了61秒，所以第二次的校验结果为过期！ **使用错误的token校验** ```python if __name__ == \"__main__\": res=judge_token('phyger666') print(res) 以上就是本篇的全部内容了，感谢您的阅读，我们再会。 ","date":"2021-07-15","objectID":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/:0:6","tags":["Python","FastApi","Token"],"title":"Token的生成和校验","uri":"/%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90token%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"前言 通常，我们的接口都是需要认证后才能可以访问的，前面我们介绍了 token 的生成和校验，那在 FastApi 中怎么设计需要认证的接口呢？ 定义令牌对象 oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/token/\") 以上/token/为获取 token 的 URI，具体内容如下： class Token(BaseModel): access_token: str token_type: str @app.post('/token/',response_model=Token) async def get_token(response:Response,form_data: OAuth2PasswordRequestForm = Depends()): if form_data.username=='phyger' and form_data.password=='phyger666': response.headers['access_token']=create_token() return {\"access_token\":create_token(),\"token_type\":\"bearer\"} /token/可以返回指定格式的令牌信息。 定义需要认证的接口 @app.get('/format/{name}') async def fmt(name,token=Depends(oauth2_scheme)): print(token) print(type(name)) new_name = name.title() return {'result':new_name} ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:0","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"直接访问此接口 \" 如上，直接访问会提示未认证，这样，我们已经达到了目的，但是怎么样才能实现准确无误的认证呢？ ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:1","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"带上 bearer token 试试 \" 你会发现，我们携带的错误的 token 也能成功，这是为什么呢？ 因为在接口中，我们通过 oauth2_scheme 拿到了 token，这个 token 是标准的 bearer 格式，但是我们没有对其进行校验，所以只要格式正确，接口都能正常返回。 ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:2","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"使用错误的 bearer 格式 \" 如上，使用错误的 bearer 格式的 token，就无法访问接口了。 获取和校验 token 思路：通过上面的代码，我们将获取 token，校验 token 封装成一个静态方法，在需要认证的接口中对这个方法进行依赖即可。 ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:3","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"封装的接口 from utm import judge_token def login_required(token=Depends(oauth2_scheme)): credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"认证失败！\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) if judge_token(token=token): return True else: raise credentials_exception ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:4","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"需要认证的接口 @app.get('/format/{name}') async def fmt(name,token=Depends(login_required)): print(token) print(type(name)) new_name = name.title() return {'result':new_name} ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:5","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"直接访问/format/{name}接口 \" 提示：未认证！ ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:6","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"携带过期的 token 访问 \" 提示：认证失败！ ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:7","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"使用错误 bearer 格式 \" 提示：未认证！ ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:8","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶","web开发","FastApi"],"content":"使用正确有效的 token \" 如上，成功！ 上面，我们将 token 错误，token 过期都统一定义为认证失败！后续可以进行细化。还需要考虑 token 续签的实现。 ","date":"2021-07-15","objectID":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/:0:9","tags":["Python","FastApi","Token"],"title":"Token的获取和使用-FastApi版","uri":"/%E5%85%A8%E6%98%AF%E7%B2%BE%E5%8D%8Etoken%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8-fastapi%E7%89%88/"},{"categories":["Python","Python进阶"],"content":"什么是装饰器 接“闭包”是什么？，我们可以认为装饰器就是一个闭包函数，同时它也返回了一个函数。 你也可以认为装饰器就是将函数作为参数传递到方法中，进行加工，再返回出来。 装饰器的使用场景 1、附加功能（统一日志格式，定时器） 2、数据的清理和添加（注入类似动态token的数据，修改清理内部数据） 3、函数注册等 装饰器的demo 1、实现函数在执行前后所花费的时间 装饰器的使用格式：@decorator # 定义装饰器 import time def execTime(func): def inner(*args,**kwargs): # 接收参数 time1 = time.time() res = func(*args,**kwargs) time2 = time.time() print(func.__name__,'执行花费',time2-time1,'s') return res # 返回func的返回值 return inner # 返回inner方法对象 # 在execAdd方法上使用execTime装饰器 @execTime def execAdd(a,b): time.sleep(1) return a+b # 调用execAdd res = execAdd(1,2) print(res) 运行结果： python3 test.py execAdd 执行花费 1.0000572204589844 s 3 2、实现日志的统一打印 import time,logging def execTime(func): def inner(*args,**kwargs): time1 = time.time() # 添加方法开始的日志 logging.warning('now func {} start...'.format(func.__name__)) res = func(*args,**kwargs) # 添加方法结束的日志 logging.warning('now func {} finished...'.format(func.__name__)) time2 = time.time() print(func.__name__,'执行花费',time2-time1,'s','\\n') return res return inner @execTime def execAdd(a,b): time.sleep(1) return a+b @execTime def sayHi(name): print('hello,{}.'.format(name)) sayHi('phyger') res = execAdd(1,2) print(res) 输出 python3 test.py WARNING:root:now func sayHi start... hello,phyger. WARNING:root:now func sayHi finished... sayHi 执行花费 0.00700068473815918 s WARNING:root:now func execAdd start... WARNING:root:now func execAdd finished... execAdd 执行花费 1.0020573139190674 s 3 你会看到上面的两个方法在执行前后都会被增加开始和结束的告警日志，而且会统计方法的执行时间，通过这种方式我们可以方便快捷的对方法进行封装。 注意 当我们执行以下代码时： @execTime def sayHi(name): print('hello,{}.'.format(name)) 输出 python3 test.py WARNING:root:now func sayHi start... hello,phyger. WARNING:root:now func sayHi finished... sayHi 执行花费 0.018001317977905273 s inner sayHi方法的name竟然是装饰器的内函数的方法，这不是我们的期望结果啊。我们方法的name和注释被装饰器内函数重写了，我们怎么解决这个问题呢？ Python帮我提供了一个函数来解决这个问题，他就是functools.wraps。 我们重写装饰器来看看效果： from functools import wraps import time,logging def execTime(func): @wraps(func) def inner(*args,**kwargs): time1 = time.time() logging.warning('now func {} start...'.format(func.__name__)) res = func(*args,**kwargs) logging.warning('now func {} finished...'.format(func.__name__)) time2 = time.time() print(func.__name__,'执行花费',time2-time1,'s','\\n') return res return inner # 调用 sayHi('phyger') print(sayHi.__name__) 输出 test.py WARNING:root:now func sayHi start... hello,phyger. WARNING:root:now func sayHi finished... sayHi 执行花费 0.003000020980834961 s sayHi 你能看到，使用了装饰器的sayHi方法的__name__值已经是它自身的值了。 如果你想在当前装饰器的基础上再增加功能，那么你可能需要使用类装饰器，因为类的继承特性可以很好的解决你这个需求。关于类装饰器我们后面再介绍。 ","date":"2021-07-15","objectID":"/%E7%AE%80%E6%98%8E%E5%BD%BB%E5%BA%95%E6%90%9E%E6%B8%85%E6%A5%9Apython%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8-python-%E4%B8%BB%E9%A2%98%E6%9C%88/:0:0","tags":["Python","装饰器"],"title":"彻底搞清楚Python的装饰器","uri":"/%E7%AE%80%E6%98%8E%E5%BD%BB%E5%BA%95%E6%90%9E%E6%B8%85%E6%A5%9Apython%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8-python-%E4%B8%BB%E9%A2%98%E6%9C%88/"},{"categories":["Markdown","野生技术"],"content":"背景 刚才在某群里无意间看到有位掘友提问：这个插入的图片怎么居中显示？其实我也早有这个疑问，只是懒得去处理。但是看到掘友有疑问，那作为热心肠的我必须帮他答疑解惑。 ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:0:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["Markdown","野生技术"],"content":"掘金原始居中方式 你会发现掘金原始的图片并不居中 尝试第1次 我们都知道，无论是Markdown还是富文本编辑器，最终在网页上的呈现方式都是一样的，无非是HTML+CSS+JS，通过以上简单的理论，我们开始第一次尝试，计划直接将Markdown的图片展示方式用HTML的\u003cimg\u003e标签替代。 ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:1:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["Markdown","野生技术"],"content":"代码 \u003cimg style=\"align:center\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58935071dcee4613bf27ec6e9bb10bc6~tplv-k3u1fbpfcp-watermark.image\" /\u003e ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:2:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["Markdown","野生技术"],"content":"效果 你会发现依然不居中，原因竟是直接在img标签中添加的样式竟然没有生效，证据如下。 尝试第2次 经过上面的失败，我们决定换一种方式，即直接使用style标签来定义样式。 ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:3:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["Markdown","野生技术"],"content":"代码 \u003cstyle type=\"text/css\"\u003e img {align:center} \u003c/style\u003e \u003cimg style=\"align:center\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58935071dcee4613bf27ec6e9bb10bc6~tplv-k3u1fbpfcp-watermark.image\" /\u003e ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:4:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["Markdown","野生技术"],"content":"效果 img {align:center} -_-// 简直没脸看啊，样式直接漏了。 尝试第3次 经过上面的失败，我决定了这次再不成功，我就弃笔从戎了！估计我这小身板儿也进不了部队，哈哈哈。这次我们计划用div包裹img标签，因为通常前端都是这么干的。 ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:5:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["Markdown","野生技术"],"content":"代码 \u003cdiv align=center\u003e \u003cimg src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58935071dcee4613bf27ec6e9bb10bc6~tplv-k3u1fbpfcp-watermark.image\" /\u003e \u003c/div\u003e ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:6:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["Markdown","野生技术"],"content":"效果 (#^.^#)，我去，终于成了。虽然这是很简单的基操，但是能够帮到掘友，我还是很开心的。 多说一句 通过这篇文章，我建议各位掘友能够动手去设计属于自己的主题并且贡献给社区，这样对于推动社区体验无疑是一件小但很好的事情。 以上就是本文的全部内容，如果喜欢记得（四连）：点赞，评论，收藏，转发。 ","date":"2021-07-15","objectID":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/:7:0","tags":["Markdown"],"title":"掘金Markdown编辑器中的图片怎么居中？","uri":"/%E6%8E%98%E9%87%91markdown%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E5%B1%85%E4%B8%AD/"},{"categories":["前端技术"],"content":"前言 相信很多同学在学习 Vue 的时候，会经常用到或者被问题到单向数据流和双向数据绑定的概念，那它两到底有什么区别呢？我们一起来看看。 单向数据流 单向数据流在 Vue 中实际表现就是：当 Model 中的 data 发生变化的时候会单向修改 View 中的值，而 View 中的值发生变化的时候，Model 不会感知。实际应用就是 v-bind 单向数据。 双向数据绑定 和单向数据流相比，双向数据绑定就是多了 View 变化会通知到 Model 层。即 MVVM 的具体实现。无论 Model 还是 View 中的值发生变化，都会通过 ViewModel 通知到对方，实现同步。实际应用就是 v-model 双向数据绑定。 代码 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003ctitle\u003e单向\u0026双向\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003e单向数据流\u003c/h1\u003e 现在的时间是：{{ mytime }} \u003cbr\u003e \u003cbutton type=\"button\" @click=\"shuax\"\u003e刷新时间\u003c/button\u003e \u003cbr\u003e\u003cbr\u003e \u003chr \u003e \u003ch1\u003e双向数据绑定\u003c/h1\u003e \u003cinput v-model=\"sxbind\"/\u003e \u003cbr\u003e 你输入的数据是：{{ sxbind }} \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e app = new Vue({ el: '#app', data: { mytime:new Date().toLocaleTimeString(), sxbind:'' }, methods: { shuax:function(){ this.mytime = new Date().toLocaleTimeString(); } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 单向数据流效果 初始页面↑ 初始页面 \" 初始页面 点击刷新时间↑ 点击刷新时间（Model变化View也变） \" 点击刷新时间 Model变化View也变↑ Model变化View也变 \" Model变化View也变 View变化Model不变↑ View变化Model不变 \" View变化Model不变 双向数据绑定效果 Model变化View也变↑ Model变化View也变 \" Model变化View也变 Model变化View也变↑ View变化Model也变 \" Model变化View也变 总结 单向数据流是通过 props 将 Model 层的变化通知到 View 层进行修改。双向数据绑定是通过 Object.defineProperty()的 set() 和 get() 方法来实现的，当某一方发生变化的时候，另一方就会收到更新值的提醒，从而实现数据同步变化。 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-07-14","objectID":"/vue%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/:0:0","tags":["Vue","前端"],"title":"Vue的单向数据流和双向数据绑定","uri":"/vue%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"},{"categories":["Vue简明教程","前端技术"],"content":"什么是 Vue 众所周知，Vue 是前端领域知名的渐进式框架。有了它，我们不用直接操作 DOM，Vue 为我们提供了很多优雅的操作 DOM 的接口。使用 Vue 进行前端工程开发已经成为相当一部分开发者的选择。 如何使用 Vue 和其他框架一样，Vue 也拥有 CDN 在线加速资源，初学，我建议使用在线 CDN 进行学习。 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:0:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"推荐的 Vue 的 CDN 资源 \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e 你只需要将如上代码复制粘贴到 HTML 的 head 部分即可。 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:1:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"Demo-1-模板渲染 此 Demo 实现通过 Vue 对 DOM 进行数据渲染。 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003e{{ messages }}\u003c/h1\u003e \u003c/div\u003e \u003cscript\u003e var app1 = new Vue ( { el: '#app', data: { messages: 'hello Vue!' } } ) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:2:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"页面效果 页面效果\" 页面效果 现在页面的模板对象已经被 Vue 渲染，数据和 DOM 进行了绑定，数据由 Vue 提供，那我们如何确认呢？ 我们可以在控制台对 Vue 对象的数据元素进行修改，查看 DOM 会不会同步变化。 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:2:1","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"执行命令 app1.messages='hello Phyger!' ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:3:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"修改前 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:4:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"修改后 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:5:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"Demo-2-实战 此实战利用数据渲染简单实现点击按钮，显示当前时间的功能。 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:6:0","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003e{{ messages }}\u003c/h1\u003e \u003cbutton v-on:click='sj'\u003e点我查看当前时间\u003c/button\u003e \u003c/div\u003e \u003cscript\u003e var app1 = new Vue ( { el: '#app', data: { messages: 'hello Vue!' }, methods:{ sj: function(){ this.messages='当前时间：' + new Date().toLocaleTimeString() } } } ) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:6:1","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"页面效果 页面效果\" 页面效果 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:6:2","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":["Vue简明教程","前端技术"],"content":"点击按钮后的效果 页面效果\" 页面效果 再点击一次 页面效果\" 页面效果 以上就是今天的全部内容了，感谢您的阅读，我们下节再会。 ","date":"2021-06-15","objectID":"/vue-1-%E5%88%9D%E8%AF%86/:6:3","tags":["Vue","前端"],"title":"Vue-1-初识","uri":"/vue-1-%E5%88%9D%E8%AF%86/"},{"categories":null,"content":"Title 野生程序员 Major CloudNative、Python Email 463551098@qq.com More 公众号：Python测试和开发 扫码关注 ","date":"2021-06-11","objectID":"/about/:0:0","tags":null,"title":"关于博主","uri":"/about/"}]